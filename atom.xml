<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>关于数据库的一切</title>
  <icon>https://www.gravatar.com/avatar/60437615b712b01d1a7c334c61fc1a4f</icon>
  <subtitle>罗济高的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cakebytheoceanluo.github.io/"/>
  <updated>2020-10-28T13:05:28.249Z</updated>
  <id>https://cakebytheoceanluo.github.io/</id>
  
  <author>
    <name>罗济高</name>
    <email>luojigao@outlook.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Leetcode-Algorithm] 11.container-with-most-water</title>
    <link href="https://cakebytheoceanluo.github.io/2020/10/28/Leetcode-Algorithm-11-container-with-most-water/"/>
    <id>https://cakebytheoceanluo.github.io/2020/10/28/Leetcode-Algorithm-11-container-with-most-water/</id>
    <published>2020-10-28T13:04:58.000Z</published>
    <updated>2020-10-28T13:05:28.249Z</updated>
    
    <content type="html"><![CDATA[<p>11.Container With Most Water</p><p>Given $n$ non-negative integers $a_1, a_2, \dots a_n$ , where each represents a point at coordinate $(i, a_i)$. $n$ vertical lines are drawn such that the two endpoints of the line $i$ is at $(i, a_i)$ and $(i, 0)$. Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.</p><p>Notice that you may not slant the container.</p><hr><p>Example 1:</p><p><img data-src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="Source: https://leetcode.com/problems/container-with-most-water/"></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: height = [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br><span class="line">Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</span><br></pre></td></tr></tbody></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: height = [1,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></tbody></table></figure><p>Example 3:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: height = [4,3,2,1,4]</span><br><span class="line">Output: 16</span><br></pre></td></tr></tbody></table></figure><p>Example 4:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: height = [1,2,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></tbody></table></figure><p>Constraints:<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 &lt;= height.length &lt;= 3 * 104</span><br><span class="line">0 &lt;= height[i] &lt;= 3 * 104</span><br></pre></td></tr></tbody></table></figure><p></p><a id="more"></a><h1 id="解法-双指针-Two-Pointer"><a href="#解法-双指针-Two-Pointer" class="headerlink" title="解法 - 双指针 Two Pointer"></a>解法 - 双指针 Two Pointer</h1><p>关键点：</p><ul><li>一开始先对这个<strong>循环 遍历</strong>:</li><li>我们相互靠近左右指针</li><li>就像我们在生活中所知道的那样: <strong>短板很重要</strong>. 因此我们<strong>每次只移动短板</strong>，这样才有可能增加体积(我们的目的)</li><li>循环遍历至左右指针重叠，这时候停止。</li></ul><p><img data-src="https://github.com/MisterBooo/LeetCodeAnimation/blob/master/0011-maxArea/Animation/maxArea.gif?raw=true" alt="Source: https://github.com/MisterBooo/LeetCodeAnimation"></p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析 1"></a>分析 <sup><a href="#fn1">1</a></sup></h2><p>我们先从题目中的示例开始，一步一步地解释双指针算法的过程。稍后再给出算法正确性的证明。</p><p>题目中的示例为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 8, 6, 2, 5, 4, 8, 3, 7]</span><br><span class="line"> ^                       ^</span><br></pre></td></tr></tbody></table></figure><p>在初始时，左右指针分别指向数组的左右两端，它们可以容纳的水量为 $\min(1, 7) * 8 = 8$</p><p>此时我们需要移动一个指针。移动哪一个呢？直觉告诉我们，应该移动对应数字较小的那个指针（即此时的左指针）。这是因为，由于容纳的水量是由</p><script type="math/tex; mode=display">两个指针指向的数字中较小值 * 指针之间的距离</script><p>决定的。如果我们移动数字较大的那个指针，那么前者「两个指针指向的数字中较小值」不会增加，后者「指针之间的距离」会减小，那么这个乘积会减小。<strong>因此，我们移动数字较大的那个指针是不合理的。因此，我们移动 数字较小的那个指针。</strong></p><p>有读者可能会产生疑问：我们可不可以同时移动两个指针？ 先别急，我们先假设 总是移动数字较小的那个指针 的思路是正确的，在走完流程之后，我们再去进行证明。</p><p>所以，我们将左指针向右移动：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 8, 6, 2, 5, 4, 8, 3, 7]</span><br><span class="line">    ^                    ^</span><br></pre></td></tr></tbody></table></figure><p>此时可以容纳的水量为 $\min(8, 7) * 7 = 49$。由于右指针对应的数字较小，我们移动右指针：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 8, 6, 2, 5, 4, 8, 3, 7]</span><br><span class="line">    ^                 ^</span><br></pre></td></tr></tbody></table></figure><p>此时可以容纳的水量为 $\min(8, 3) * 6 = 18$。由于右指针对应的数字较小，我们移动右指针：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 8, 6, 2, 5, 4, 8, 3, 7]</span><br><span class="line">    ^              ^</span><br></pre></td></tr></tbody></table></figure><p>此时可以容纳的水量为 $\min(8, 8) * 5 = 40$。两指针对应的数字相同，我们可以任意移动一个，例如左指针：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 8, 6, 2, 5, 4, 8, 3, 7]</span><br><span class="line">       ^           ^</span><br></pre></td></tr></tbody></table></figure><p>此时可以容纳的水量为 $\min(6, 8) <em> 4 = 24$。由于左指针对应的数字较小，我们移动左指针，并且可以发现，在这之后左指针对应的数字总是较小，因此我们会一直移动左指针，直到两个指针重合。在这期间，对应的可以容纳的水量为：$\min(2, 8) </em> 3 = 6$，$\min(5, 8) <em> 2 = 10$，$\min(4, 8) </em> 1 = 4$。</p><p>在我们移动指针的过程中，计算到的最多可以容纳的数量为 $49$，即为最终的答案。</p><h2 id="证明-1"><a href="#证明-1" class="headerlink" title="证明 1"></a>证明 <sup><a href="#fn1">1</a></sup></h2><p>为什么双指针的做法是正确的？</p><ul><li>双指针代表了什么？</li></ul><p>双指针代表的是 <strong>可以作为容器边界的所有位置的范围</strong>。在一开始，双指针指向数组的左右边界，表示 <strong>数组中所有的位置都可以作为容器的边界</strong>，因为我们还没有进行过任何尝试。在这之后，我们每次将 <strong>对应的数字较小的那个指针 往 另一个指针 的方向移动一个位置</strong>，就表示我们认为 这个指针不可能再作为容器的边界了。</p><ul><li>为什么对应的数字较小的那个指针不可能再作为容器的边界了？</li></ul><p>在上面的分析部分，我们对这个问题有了一点初步的想法。这里我们定量地进行证明。</p><p><strong>考虑第一步</strong>，假设当前左指针和右指针指向的数分别为 $x$ 和 $y$，不失一般性，我们假设 $x \leq y$。同时，两个指针之间的距离为 $t$。那么，它们组成的容器的容量为：</p><script type="math/tex; mode=display">\min(x, y) * t = x * t</script><p>我们可以断定，<strong>如果我们保持左指针的位置不变，那么无论右指针在哪里，这个容器的容量都不会超过</strong> $x * t$ 了。注意这里右指针只能向左移动，因为 我们考虑的是第一步，也就是 指针还指向数组的左右边界的时候。</p><p>我们任意向左移动右指针，指向的数为 $y_1$,两个指针之间的距离为 $t_1$ ，那么显然有 $t_1 &lt; t$，并且 $\min(x, y_1) \leq \min(x, y)$：</p><ul><li>如果 $y_1 \leq y$，那么 $\min(x, y_1) \leq \min(x, y)$</li><li>如果 $y_1 &gt; y$，那么 $\min(x, y_1) = x = \min(x, y)$</li></ul><p>因此有：</p><script type="math/tex; mode=display">\min(x, y_t) * t_1 < \min(x, y) * t</script><p><strong>即无论我们怎么移动右指针，得到的容器的容量都小于移动前容器的容量。也就是说，这个左指针对应的数不会作为容器的边界了，那么我们就可以丢弃这个位置，将左指针向右移动一个位置，此时新的左指针于原先的右指针之间的左右位置，才可能会作为容器的边界。</strong></p><p>这样以来，我们将问题的规模减小了 $1$，被我们丢弃的那个位置就相当于消失了。<strong>此时的左右指针，就指向了一个新的、规模减少了的问题的数组的左右边界，因此，我们可以继续像之前 考虑第一步 那样考虑这个问题</strong>：</p><ul><li><p>求出当前双指针对应的容器的容量；</p></li><li><p>对应数字较小的那个指针以后不可能作为容器的边界了，将其丢弃，并移动对应的指针。</p></li></ul><p>最后的答案是什么？ 答案就是我们每次以双指针为左右边界（也就是「数组」的左右边界）计算出的容量中的最大值。</p><p><br><br><br></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>{</span><br><span class="line">        <span class="comment">// Init with -1. (A valid result should be non-negative).</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> left = <span class="built_in">height</span>.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">auto</span> right = <span class="built_in">height</span>.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">            result = <span class="built_in">std</span>::<span class="built_in">max</span>&lt;<span class="keyword">int</span>&gt;(result, <span class="built_in">std</span>::<span class="built_in">min</span>&lt;<span class="keyword">int</span>&gt;(*left, *right) * <span class="built_in">std</span>::distance(left, right));</span><br><span class="line">            <span class="keyword">if</span> (*left &lt; *right) {</span><br><span class="line">                ++left;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                --right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        assert(result &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>复杂度:</p><ul><li>时间复杂度: $O(N)$ 双指针总计最多遍历整个数组一次</li><li>空间复杂度：$O(1)$</li></ul><p><br></p><p>引用和推荐的阅读：</p><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY29udGFpbmVyLXdpdGgtbW9zdC13YXRlci8=" title="https://leetcode.com/problems/container-with-most-water/">https://leetcode.com/problems/container-with-most-water/<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY29udGFpbmVyLXdpdGgtbW9zdC13YXRlci9zb2x1dGlvbi8=" title="https://leetcode.com/problems/container-with-most-water/solution/">https://leetcode.com/problems/container-with-most-water/solution/<i class="fa fa-external-link"></i></span></p><ul><li><a name="fn1">1</a>: <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29udGFpbmVyLXdpdGgtbW9zdC13YXRlci9zb2x1dGlvbi9zaGVuZy16dWktZHVvLXNodWktZGUtcm9uZy1xaS1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=" title="https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/">https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/<i class="fa fa-external-link"></i></span></li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01pc3RlckJvb28vTGVldENvZGVBbmltYXRpb24vYmxvYi9tYXN0ZXIvMDAxMS1tYXhBcmVhL0FydGljbGUvMDAxMS1tYXhBcmVhLm1k" title="https://github.com/MisterBooo/LeetCodeAnimation/blob/master/0011-maxArea/Article/0011-maxArea.md">https://github.com/MisterBooo/LeetCodeAnimation/blob/master/0011-maxArea/Article/0011-maxArea.md<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2F6bDM5Nzk4NTg1Ni9sZWV0Y29kZS9ibG9iL21hc3Rlci9wcm9ibGVtcy8xMS5jb250YWluZXItd2l0aC1tb3N0LXdhdGVyLm1k" title="https://github.com/azl397985856/leetcode/blob/master/problems/11.container-with-most-water.md">https://github.com/azl397985856/leetcode/blob/master/problems/11.container-with-most-water.md<i class="fa fa-external-link"></i></span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;11.Container With Most Water&lt;/p&gt;
&lt;p&gt;Given $n$ non-negative integers $a_1, a_2, \dots a_n$ , where each represents a point at coordinate $(i, a_i)$. $n$ vertical lines are drawn such that the two endpoints of the line $i$ is at $(i, a_i)$ and $(i, 0)$. Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.&lt;/p&gt;
&lt;p&gt;Notice that you may not slant the container.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg&quot; alt=&quot;Source: https://leetcode.com/problems/container-with-most-water/&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: height = [1,8,6,2,5,4,8,3,7]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Example 2:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: height = [1,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Example 3:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: height = [4,3,2,1,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Example 4:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: height = [1,2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Constraints:&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;2 &amp;lt;= height.length &amp;lt;= 3 * 104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;= height[i] &amp;lt;= 3 * 104&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://cakebytheoceanluo.github.io/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="https://cakebytheoceanluo.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://cakebytheoceanluo.github.io/tags/Leetcode/"/>
    
      <category term="C++" scheme="https://cakebytheoceanluo.github.io/tags/C/"/>
    
      <category term="Two Pointers" scheme="https://cakebytheoceanluo.github.io/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode-Algorithm] 16.3-sum-closest</title>
    <link href="https://cakebytheoceanluo.github.io/2020/10/27/Leetcode-Algorithm-16-3-sum-closest/"/>
    <id>https://cakebytheoceanluo.github.io/2020/10/27/Leetcode-Algorithm-16-3-sum-closest/</id>
    <published>2020-10-27T18:33:58.000Z</published>
    <updated>2020-10-27T18:34:29.057Z</updated>
    
    <content type="html"><![CDATA[<p>16.3Sum Closest</p><p>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><p>Example:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [-1, 2, 1, -4], and target = 1.</span><br><span class="line"></span><br><span class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><h1 id="解法-双指针-Two-Pointer"><a href="#解法-双指针-Two-Pointer" class="headerlink" title="解法 - 双指针 Two Pointer"></a>解法 - 双指针 Two Pointer</h1><p>关键点：</p><ul><li>一开始先对这个<code>vector</code>排序, 然后开始我们的<strong>循环 遍历</strong>:<ul><li>从右开始选择一个数<code>first</code>。然后再去找<code>first</code>右边的邻居<code>second</code>。然后再binary search到对应的<code>third</code>。然后我们依然用<strong>Two Pointer双指针</strong>的方法，让俩指针<code>second, third</code>相互靠近，去检查是否有我们的解 或者一个更优的解。通过双指针查找，转化为2sum closest的问题<ul><li>左指针<code>left = first + 1</code>，右指针 <code>right = binary_search(0 - *first - *left)</code>，当 <code>second &lt; third</code> 时，执行循环：<ul><li>当 <code>*first + *second + *third == target</code> ，直接返回target。这已经是最优情况。</li><li>如果有更优情况，更新我们的记录。</li><li>若和大于 <code>target</code>，说明 <code>*third</code> 太大，<code>third</code> 左移</li><li>若和小于 <code>target</code>，说明 <code>*second</code> 太小，<code>second</code> 右移</li></ul></li></ul></li></ul></li><li>循环遍历至<code>first</code>触碰到第一个正数，这时候停止。</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for example:</span><br><span class="line">   [-4,-1,-1,1,2]    target=1</span><br><span class="line"></span><br><span class="line">   take -4, can cacluate the "two number problem" of the reset array [-1,-1,1,2] while target=5</span><br><span class="line">   [(-4),-1,-1,1,2]  target=5  distance=4</span><br><span class="line">          ^      ^ </span><br><span class="line">   because the -1+2 = 1 which &lt; 5, then move the `low` pointer(skip the duplication)</span><br><span class="line">   [(-4),-1,-1,1,2]  target=5  distance=2</span><br><span class="line">               ^ ^ </span><br><span class="line">   take -1(skip the duplication), can cacluate the "two number problem" of the reset array [1,2] while target=2</span><br><span class="line">   [-4,-1,(-1),1,2]  target=2  distance=1</span><br></pre></td></tr></tbody></table></figure><p><br><br><br></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="comment">// assert(nums.size() &gt;= 3);</span></span><br><span class="line">        <span class="comment">// Sort the vector in a ascending order. Modify the vector XD</span></span><br><span class="line">        <span class="built_in">std</span>::sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Main idea: iterate all elements in vector. To find the closest.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Init the result with max value. The target can be positive as well as negative.</span></span><br><span class="line">        <span class="keyword">int</span> closest = <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> first = nums.<span class="built_in">begin</span>(); first + <span class="number">2</span> != nums.<span class="built_in">end</span>(); ++first) {</span><br><span class="line">            <span class="comment">// The first element is firsted. Problem reduced to find closest 2sum in remaining part of vector.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// The second is the next.</span></span><br><span class="line">            <span class="keyword">auto</span> second = first + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// Locate the third.</span></span><br><span class="line">            <span class="keyword">auto</span> third = <span class="built_in">std</span>::upper_bound(second + <span class="number">1</span>, nums.<span class="built_in">end</span>(), target - *first - *second);</span><br><span class="line">            <span class="keyword">if</span> (third == nums.<span class="built_in">end</span>()) {</span><br><span class="line">                third--;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Move second to the right. Move third to the left.</span></span><br><span class="line">            <span class="keyword">while</span> (second &lt; third &amp;&amp; third &lt; nums.<span class="built_in">end</span>()) {</span><br><span class="line">                <span class="keyword">if</span> (*first + *second + *third == target) {</span><br><span class="line">                    <span class="keyword">return</span> target; <span class="comment">// Return perfect match.</span></span><br><span class="line">                }</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (closest == <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>() || <span class="built_in">std</span>::<span class="built_in">abs</span>(*first + *second + *third - target) &lt; <span class="built_in">std</span>::<span class="built_in">abs</span>(closest - target)) { </span><br><span class="line">                    closest = *first + *second + *third;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (*first + *second + *third &gt; target) {</span><br><span class="line">                    --third;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    ++second;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> closest;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>重点:</p><ul><li><code>auto third = std::upper_bound(second + 1, nums.end(), target - *first - *second);</code> 基本是一个binary search的实现。查到我们需要处理的最大的值，即最右边并且有必要查看的值。想象这个vector非常大，后面的部分的数值很大，都不需要查看。</li><li>我个人觉可以使用这个binary search。我在下面链接的其他答案没有使用这个点，从头一个元素和最后一个元素开始检查。</li></ul><p>其他小的地方:</p><ul><li><code>assert</code>好像会影响Leetcode上面runtime, memory usage的性能。</li></ul><p>复杂度:</p><ul><li>时间复杂度: $O(N^2)$<ul><li>数组排序 $O(NlogN)$, 遍历数组$O(n)$, 双指针遍历 $O(n)$, 总体复杂度为 $O(NlogN) + O(n) * O(n) = O(n^2)$</li></ul></li><li>空间复杂度：$O(logN)$ (assumed quick-sort)</li></ul><p><br></p><p>引用和推荐的阅读：</p><p><span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2FsZ29yaXRobS9sb3dlcl9ib3VuZA==" title="https://en.cppreference.com/w/cpp/algorithm/lower_bound">https://en.cppreference.com/w/cpp/algorithm/lower_bound<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2FsZ29yaXRobS91cHBlcl9ib3VuZA==" title="https://en.cppreference.com/w/cpp/algorithm/upper_bound">https://en.cppreference.com/w/cpp/algorithm/upper_bound<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvM3N1bS1jbG9zZXN0" title="https://leetcode.com/problems/3sum-closest">https://leetcode.com/problems/3sum-closest<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvM3N1bS1jbG9zZXN0L3NvbHV0aW9uL3p1aS1qaWUtamluLWRlLXNhbi1zaHUtemhpLWhlLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==" title="https://leetcode-cn.com/problems/3sum-closest/solution/zui-jie-jin-de-san-shu-zhi-he-by-leetcode-solution/">https://leetcode-cn.com/problems/3sum-closest/solution/zui-jie-jin-de-san-shu-zhi-he-by-leetcode-solution/<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZWNuL0ludGVydmlldy9ibG9iL21hc3Rlci9kb2NzL0FsZ29yaXRobS9MZWV0Y29kZS9DJTJCJTJCLzAwMTYuXzNTdW1fQ2xvc2VzdC5tZA==" title="https://github.com/apachecn/Interview/blob/master/docs/Algorithm/Leetcode/C%2B%2B/0016._3Sum_Closest.md">https://github.com/apachecn/Interview/blob/master/docs/Algorithm/Leetcode/C%2B%2B/0016._3Sum_Closest.md<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xlb1Npcml1cy9sZWV0Y29kZV9zb2x1dGlvbnMvYmxvYi9tYXN0ZXIvMDAxNl8zU3VtX0Nsb3Nlc3QvU29sdXRpb24xLmNwcA==" title="https://github.com/LeoSirius/leetcode_solutions/blob/master/0016_3Sum_Closest/Solution1.cpp">https://github.com/LeoSirius/leetcode_solutions/blob/master/0016_3Sum_Closest/Solution1.cpp<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhb2VsL2xlZXRjb2RlL2Jsb2IvbWFzdGVyL2FsZ29yaXRobXMvY3BwLzNTdW1DbG9zZXN0LzNTdW1DbG9zZXN0LmNwcA==" title="https://github.com/haoel/leetcode/blob/master/algorithms/cpp/3SumClosest/3SumClosest.cpp">https://github.com/haoel/leetcode/blob/master/algorithms/cpp/3SumClosest/3SumClosest.cpp<i class="fa fa-external-link"></i></span> (过于复杂了)</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;16.3Sum Closest&lt;/p&gt;
&lt;p&gt;Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Given array nums = [-1, 2, 1, -4], and target = 1.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://cakebytheoceanluo.github.io/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="https://cakebytheoceanluo.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://cakebytheoceanluo.github.io/tags/Leetcode/"/>
    
      <category term="C++" scheme="https://cakebytheoceanluo.github.io/tags/C/"/>
    
      <category term="Two Pointers" scheme="https://cakebytheoceanluo.github.io/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>[CMU-15445]Lec12 Query Processing I</title>
    <link href="https://cakebytheoceanluo.github.io/2020/10/19/CMU-15445-Lec12/"/>
    <id>https://cakebytheoceanluo.github.io/2020/10/19/CMU-15445-Lec12/</id>
    <published>2020-10-19T07:54:52.000Z</published>
    <updated>2020-10-19T09:13:19.784Z</updated>
    
    <content type="html"><![CDATA[<p>Query Execution I - Query执行</p><p>Slide: <span class="exturl" data-url="aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTkvc2xpZGVzLzEyLXF1ZXJ5ZXhlY3V0aW9uMS5wZGY=" title="https://15445.courses.cs.cmu.edu/fall2019/slides/12-queryexecution1.pdf">https://15445.courses.cs.cmu.edu/fall2019/slides/12-queryexecution1.pdf<i class="fa fa-external-link"></i></span><br>Note: <span class="exturl" data-url="aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTkvbm90ZXMvMTItcXVlcnlleGVjdXRpb24xLnBkZg==" title="https://15445.courses.cs.cmu.edu/fall2019/notes/12-queryexecution1.pdf">https://15445.courses.cs.cmu.edu/fall2019/notes/12-queryexecution1.pdf<i class="fa fa-external-link"></i></span><br>Readings:  Chapter 12.1-12.3, 12.7</p><p>我们开始学习Operator Execution执行引擎部分。这次学习的主要主题是Processing Model</p><a id="more"></a><blockquote><p>The DBMS converts a SQL statement into a query plan. Operators in the query plan are arranged in a tree. Data flows from the leaves of this tree towards the root.</p></blockquote><p><img data-src="/images/CMU1544564/Lec12/1.jpg" alt="1.jpg"></p><!-- ![2.jpg](/images/CMU1544564/Lec12/2.jpg) --><p><img data-src="/images/CMU1544564/Lec12/3.jpg" alt="3.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/4.jpg" alt="4.jpg"></p><h1 id="Processing-Models"><a href="#Processing-Models" class="headerlink" title="Processing Models"></a>Processing Models</h1><blockquote><p>A DBMS processing model defines how the system executes a query plan. <strong>It specifies things like the direction in which the query plan is read in as well as what kind of data is passed between operators along the way. There are different models of processing models that have various trade-offs for different workloads.</strong></p></blockquote><p><img data-src="/images/CMU1544564/Lec12/5.jpg" alt="5.jpg"></p><h2 id="Iterator-Volcano-Pipeline-Model"><a href="#Iterator-Volcano-Pipeline-Model" class="headerlink" title="Iterator (Volcano / Pipeline) Model"></a>Iterator (Volcano / Pipeline) Model</h2><blockquote><p><strong>The iterator model</strong>, also known as the <strong>Volcano or Pipeline model</strong>, is the most common processing model and is used by almost every (row-based) DBMS. The iterator model <strong>allows for pipelining where the DBMS can process a tuple through as many operators as possible before having to retrieve the next tuple. The series of tasks performed for a given tuple in the query plan is called a pipeline</strong>.</p><p>The iterator model works by implementing a <em>next</em> function for every operator in the database. Each node in the query plan calls <em>next</em> on its children until the leaf nodes are reached, which start emitting tuples up for processing. <strong>Each tuple is then processed up the plan as far as possible before the next tuple is retrieved. This is useful in disk-based systems because it allows us to fully use each tuple in memory before the next tuple or page is accessed.</strong> A sample diagram of the iterator model is shown in example.</p></blockquote><p><img data-src="/images/CMU1544564/Lec12/6.jpg" alt="6.jpg"></p><blockquote><p>In this way, calling next on a parent calls next on its children. In response, the child node will return the next tuple that the parent must process</p></blockquote><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><blockquote><p>Pseudo code of the different <em>next</em> functions for each of the operators. The <em>next</em> functions are essentially for loops iterating over the output of their child operator. For example, the root node calls <em>next</em> on its child, the join operator, which is an access method that loops over the relation R and emits a tuple up that is then operated on. After all tuples have been processed, a null pointer is sent that lets the parent nodes know to move on.</p></blockquote><p><img data-src="/images/CMU1544564/Lec12/7.jpg" alt="7.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/8.jpg" alt="8.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/9.jpg" alt="9.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/10.jpg" alt="10.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/11.jpg" alt="11.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/12.jpg" alt="12.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/13.jpg" alt="13.jpg"></p><blockquote><p>Some operators will block until children emit all of their tuples (joins, subqueries, order by). These are known as pipeline breakers.<br>  Output control works easily with this approach (LIMIT) because an operator can stop invoking next on its children operators once it has all the tuples that it requires.</p></blockquote><p><br><br><br></p><h2 id="Materialization-Model"><a href="#Materialization-Model" class="headerlink" title="Materialization Model"></a>Materialization Model</h2><blockquote><p>The materialization model is a specialization of the iterator model where <strong>each operator processes its input all at once and then emits its output all at once</strong>. Instead of having a next function that returns a single tuple, <strong>each operator returns all of its tuples every time it is reached. To avoid scanning too many tuples, the DBMS can propagate down information about how many tuples are needed to subsequent operators.</strong> The operator “materializes” its output as a single result. The output can be either a whole tuple (NSM) or a subset of columns (DSM). A diagram of the materialization model is shown in example.</p><p>Every query plan operator implements an <em>output</em> function:</p><ul><li><strong>The operator processes all the tuples from its children at once.</strong></li><li><strong>The return result of this function is all the tuples that operator will ever emit. When the operator finishes executing, the DBMS never needs to return to it to retrieve more data.</strong></li></ul></blockquote><p><img data-src="/images/CMU1544564/Lec12/14.jpg" alt="14.jpg"></p><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><blockquote><p>Materialization Model Example - Starting at the root, the <em>child.Output()</em> function is called, which invokes the operators below, which returns <strong>all tuples back up</strong>.</p></blockquote><p><img data-src="/images/CMU1544564/Lec12/15.jpg" alt="15.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/16.jpg" alt="16.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/17.jpg" alt="17.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/18.jpg" alt="18.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/19.jpg" alt="19.jpg"></p><blockquote><p>This approach is <strong>better for OLTP workloads</strong> because queries typically only access a small number of tuples at a time. Thus, there are fewer function calls to retrieve tuples.<br>  The materialization model is <strong>not suited for OLAP queries</strong> with large intermediate results because the DBMS may have to spill those results to disk between operators.</p></blockquote><p><br><br><br></p><h2 id="Vectorization-Model"><a href="#Vectorization-Model" class="headerlink" title="Vectorization Model"></a>Vectorization Model</h2><p>Like the iterator model, the vectorization model has each operator implements a <em>next</em> function. <strong>However, each operator emits a batch (i.e., vector) of data instead of a single tuple. The operator’s internal loop implementation is optimized for processing batches of data instead of a single item at a time.</strong> The size of the batch can vary based on hardware or query properties. See an example of the vectorization model.</p><p><img data-src="/images/CMU1544564/Lec12/20.jpg" alt="20.jpg"></p><h3 id="example-1"><a href="#example-1" class="headerlink" title="example"></a>example</h3><p> The vectorization model is very similar to<br>the iterator model except at every operator, an output buffer is compared to the desired<br>emission size. If the buffer is larger, then a tuple batch is sent up.</p><p><img data-src="/images/CMU1544564/Lec12/21.jpg" alt="21.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/22.jpg" alt="22.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/23.jpg" alt="23.jpg"></p><blockquote><p>The vectorization model approach is <strong>ideal for OLAP queries</strong> that have to scan a large number of tuples because there are fewer invocations of the next function.</p></blockquote><p><br><br><br></p><h2 id="Plan-Processing-Direction"><a href="#Plan-Processing-Direction" class="headerlink" title="Plan Processing Direction"></a>Plan Processing Direction</h2><p><img data-src="/images/CMU1544564/Lec12/24.jpg" alt="24.jpg"></p><blockquote><p>These models can also be implemented to invoke the operators either from top-to-bottom or from bottom-to-top. Although the top-to-bottom approach is much more common, <strong>the bottom-to-top approach can allow for tighter control of caches/registers in pipelines</strong>.</p></blockquote><p>(到目前为止 只是简单的概念介绍 有兴趣的同学可以自己实现一下)</p><p><br><br><br><br><br><br><br></p><h1 id="Access-Methods"><a href="#Access-Methods" class="headerlink" title="Access Methods"></a>Access Methods</h1><p><img data-src="/images/CMU1544564/Lec12/25.jpg" alt="25.jpg"></p><blockquote><p><strong>An access method is how the DBMS accesses the data stored in a table.</strong> In general, there are two approaches to access models; <strong>*either data is read from an index or from a table with a sequential scan</strong>.<br>  The* multi-index is an extension of the index scan that allows for multiple indexes to be accessed at once.</p><p>The DBMS maintains an internal cursor that tracks the last page/slot that it examined.</p></blockquote><h2 id="Sequential-Scan"><a href="#Sequential-Scan" class="headerlink" title="Sequential Scan"></a>Sequential Scan</h2><p><img data-src="/images/CMU1544564/Lec12/26.jpg" alt="26.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/27.jpg" alt="27.jpg"></p><p>部分优化之前在缓冲区管理章节提到过: <a href="https://cakebytheoceanluo.github.io/2020/03/17/CMU-15445-Lec05/#Buffer-Pool-Optimizations">[CMU-15445] Lec05 Buffer Pools - 数据库缓存区: Buffer Pool Optimizations</a></p><blockquote><ul><li>Prefetching: Fetch the next few pages in advance so that the DBMS does not have to block when accessing each page.</li><li>Parallelization: Execute the scan using multiple threads/processes in parallel.</li><li><strong>Buffer Pool Bypass: The scan operator stores pages that it fetches from disk in its local memory instead of the buffer pool in order to avoid sequential flooding.</strong></li></ul></blockquote><p><br></p><h3 id="Zone-Map"><a href="#Zone-Map" class="headerlink" title="Zone Map"></a>Zone Map</h3><blockquote><p>Zone Map: <strong>Pre-compute aggregations</strong> for each tuple attribute in a page. The DBMS can then decide whether it needs to access a page by checking its Zone Map first. The Zone Maps for each page are stored in separate pages and there are typically multiple entries in each Zone Map page. Thus, it is possible to reduce the total number of pages examined in a sequential scan. </p></blockquote><p>Zone Map在学术环境又称为 Small Materialized Aggregates: <span class="exturl" data-url="aHR0cHM6Ly9waTMuaW5mb3JtYXRpay51bmktbWFubmhlaW0uZGUvfm1vZXIvUHVibGljYXRpb25zL01BLTk4LTAxLnBkZg==" title="https://pi3.informatik.uni-mannheim.de/~moer/Publications/MA-98-01.pdf">Small Materialized Aggregates: A Light Weight Index Structure for Data Warehousing<i class="fa fa-external-link"></i></span></p><p>Zone Map也就是一些预先计算好的信息，对OLAP很有帮助，但是对update较多的OLTP不大好. 它类似于一块(block)数据的一个Header，提供一些必要信息，来加速OLAP</p><p>比如Query是<code>SELECT sum(val) FROM table;</code>，我们就只需要看这个Header中的sum就好 ,不需要重新一个一个加而去获得sum. 下图中也有另外一个例子</p><p><img data-src="/images/CMU1544564/Lec12/28.jpg" alt="28.jpg"></p><blockquote><p>Zone Map Example: The zone map stores pre-computed aggregates for values in a page. In the example above, the select query realizes from the zone map that the max value in the original data is only 400. Then, instead of having to iterate through every tuple in the page, the query can avoid accessing the page at all since none of the values will be greater than 600.</p></blockquote><h3 id="Late-Materialization"><a href="#Late-Materialization" class="headerlink" title="Late Materialization"></a>Late Materialization</h3><blockquote><p>Late Materialization: <strong>Each operator passes the minimal amount of information needed to the next operator (e.g., record id, offset to record in column).</strong> This is only useful in <strong>column-store</strong> systems (i.e., DSM).</p></blockquote><p><img data-src="/images/CMU1544564/Lec12/29.jpg" alt="29.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/30.jpg" alt="30.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/31.jpg" alt="31.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/32.jpg" alt="32.jpg"></p><h3 id="Heap-Clustering"><a href="#Heap-Clustering" class="headerlink" title="Heap Clustering"></a>Heap Clustering</h3><blockquote><p><strong>Tuples are stored in the heap pages using an order specified by a clustering index</strong>.</p></blockquote><p><a href="https://cakebytheoceanluo.github.io/2020/03/19/CMU-15445-Lec07/#Clustered-Indexes">[CMU-15445] Lec07 Tree Indexes Part I - 树索引 I: Clustered Indexes</a></p><p><img data-src="/images/CMU1544564/Lec12/33.jpg" alt="33.jpg"></p><p><br><br><br></p><h2 id="Index-Scan"><a href="#Index-Scan" class="headerlink" title="Index Scan"></a>Index Scan</h2><blockquote><p>The goal of an index scan is to identify an index in the table that will quickly allow the user to find the data he or she needs by avoiding useless operations. </p></blockquote><p><img data-src="/images/CMU1544564/Lec12/34.jpg" alt="34.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/35.jpg" alt="35.jpg"></p><blockquote><p>Index Scan Example – Consider <strong>a single table with 100 tuples and two indexes: age and department.</strong><br>  In the first scenario, it is better to use the department index in the scan because it only has two tuples to match. Choosing the age index would not be much better than a simple sequential scan.<br>  In the second scenario, the age index would eliminate more unnecessary scans and is the optimal choice.</p></blockquote><p><strong>Use index with low selectivity!</strong></p><p><br></p><h3 id="Multi-Index-Scans"><a href="#Multi-Index-Scans" class="headerlink" title="Multi-Index Scans"></a>Multi-Index Scans</h3><blockquote><p>More advanced DBMSs can support multi-index scans. When using multiple indexes for a query, <strong>the DBMS will compute sets of record IDs using each matching index, combine those sets based on the query’s predicates, and retrieve the records and apply any predicates that may remain</strong>. The DBMS can use <strong>bitmaps, hash tables, or Bloom filters to compute record IDs through set intersection</strong>.</p></blockquote><p><img data-src="/images/CMU1544564/Lec12/36.jpg" alt="36.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/37.jpg" alt="37.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/38.jpg" alt="38.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/39.jpg" alt="39.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/40.jpg" alt="40.jpg"></p><h3 id="Index-Scan-Page-Sorting"><a href="#Index-Scan-Page-Sorting" class="headerlink" title="Index Scan Page Sorting"></a>Index Scan Page Sorting</h3><p><a href="https://cakebytheoceanluo.github.io/2020/03/19/CMU-15445-Lec07/#Clustered-Indexes">[CMU-15445] Lec07 Tree Indexes Part I - 树索引 I: Clustered Indexes</a></p><p><img data-src="/images/CMU1544564/Lec12/41.jpg" alt="41.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/42.jpg" alt="42.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/43.jpg" alt="43.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/44.jpg" alt="44.jpg"></p><p><br><br><br><br><br></p><h1 id="Expression-Evaluation"><a href="#Expression-Evaluation" class="headerlink" title="Expression Evaluation"></a>Expression Evaluation</h1><blockquote><p>To evaluate an expression tree at runtime, the DBMS maintains a context handle that contains metadata for the execution, such as the current tuple, the parameters, and the table schema. The DBMS then walks the tree to evaluate its operators and produce a result.<br>Evaluating predicates in this manner is slow because the DBMS must traverse the entire tree and figure out what to do for each operator. <strong>A better approach is to just evaluate the expression directly</strong>.</p></blockquote><p>建议还是直接LLVM JIT去做这个Expression Evaluation :D</p><p><img data-src="/images/CMU1544564/Lec12/45.jpg" alt="45.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/46.jpg" alt="46.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/47.jpg" alt="47.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/48.jpg" alt="48.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/49.jpg" alt="49.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/50.jpg" alt="50.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/51.jpg" alt="51.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/52.jpg" alt="52.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/53.jpg" alt="53.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/54.jpg" alt="54.jpg"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p><img data-src="/images/CMU1544564/Lec12/55.jpg" alt="55.jpg"></p><p><img data-src="/images/CMU1544564/Lec12/56.jpg" alt="56.jpg"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Query Execution I - Query执行&lt;/p&gt;
&lt;p&gt;Slide: &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTkvc2xpZGVzLzEyLXF1ZXJ5ZXhlY3V0aW9uMS5wZGY=&quot; title=&quot;https://15445.courses.cs.cmu.edu/fall2019/slides/12-queryexecution1.pdf&quot;&gt;https://15445.courses.cs.cmu.edu/fall2019/slides/12-queryexecution1.pdf&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;Note: &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTkvbm90ZXMvMTItcXVlcnlleGVjdXRpb24xLnBkZg==&quot; title=&quot;https://15445.courses.cs.cmu.edu/fall2019/notes/12-queryexecution1.pdf&quot;&gt;https://15445.courses.cs.cmu.edu/fall2019/notes/12-queryexecution1.pdf&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;Readings:  Chapter 12.1-12.3, 12.7&lt;/p&gt;
&lt;p&gt;我们开始学习Operator Execution执行引擎部分。这次学习的主要主题是Processing Model&lt;/p&gt;
    
    </summary>
    
    
      <category term="Access Methods" scheme="https://cakebytheoceanluo.github.io/categories/Access-Methods/"/>
    
      <category term="CMU-15445" scheme="https://cakebytheoceanluo.github.io/categories/CMU-15445/"/>
    
      <category term="B Tree" scheme="https://cakebytheoceanluo.github.io/categories/B-Tree/"/>
    
      <category term="Data Structure" scheme="https://cakebytheoceanluo.github.io/categories/Data-Structure/"/>
    
      <category term="Indexing" scheme="https://cakebytheoceanluo.github.io/categories/Indexing/"/>
    
      <category term="Operator Execution / Query Processing" scheme="https://cakebytheoceanluo.github.io/categories/Operator-Execution-Query-Processing/"/>
    
      <category term="Processing Models" scheme="https://cakebytheoceanluo.github.io/categories/Processing-Models/"/>
    
      <category term="Iterator Model" scheme="https://cakebytheoceanluo.github.io/categories/Iterator-Model/"/>
    
      <category term="Materialization Model" scheme="https://cakebytheoceanluo.github.io/categories/Materialization-Model/"/>
    
      <category term="Vectorization Model" scheme="https://cakebytheoceanluo.github.io/categories/Vectorization-Model/"/>
    
    
      <category term="B Tree" scheme="https://cakebytheoceanluo.github.io/tags/B-Tree/"/>
    
      <category term="Indexing" scheme="https://cakebytheoceanluo.github.io/tags/Indexing/"/>
    
      <category term="Clustered Index" scheme="https://cakebytheoceanluo.github.io/tags/Clustered-Index/"/>
    
      <category term="Processing Models" scheme="https://cakebytheoceanluo.github.io/tags/Processing-Models/"/>
    
      <category term="Iterator Model" scheme="https://cakebytheoceanluo.github.io/tags/Iterator-Model/"/>
    
      <category term="Materialization Model" scheme="https://cakebytheoceanluo.github.io/tags/Materialization-Model/"/>
    
      <category term="Vectorization Model" scheme="https://cakebytheoceanluo.github.io/tags/Vectorization-Model/"/>
    
      <category term="Late Materialization" scheme="https://cakebytheoceanluo.github.io/tags/Late-Materialization/"/>
    
      <category term="Zone Map / SMA" scheme="https://cakebytheoceanluo.github.io/tags/Zone-Map-SMA/"/>
    
      <category term="Expression Evaluation" scheme="https://cakebytheoceanluo.github.io/tags/Expression-Evaluation/"/>
    
  </entry>
  
  <entry>
    <title>[CMU-15445]Lec11 Join Algorithms - 连接算法</title>
    <link href="https://cakebytheoceanluo.github.io/2020/10/17/CMU-15445-Lec11/"/>
    <id>https://cakebytheoceanluo.github.io/2020/10/17/CMU-15445-Lec11/</id>
    <published>2020-10-17T11:51:07.000Z</published>
    <updated>2020-10-19T07:20:10.994Z</updated>
    
    <content type="html"><![CDATA[<p>Join Algorithms - 连接算法</p><p>Slide: <span class="exturl" data-url="aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTkvc2xpZGVzLzExLWpvaW5zLnBkZg==" title="https://15445.courses.cs.cmu.edu/fall2019/slides/11-joins.pdf">https://15445.courses.cs.cmu.edu/fall2019/slides/11-joins.pdf<i class="fa fa-external-link"></i></span><br>Note: <span class="exturl" data-url="aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTkvbm90ZXMvMTEtam9pbnMucGRm" title="https://15445.courses.cs.cmu.edu/fall2019/notes/11-joins.pdf">https://15445.courses.cs.cmu.edu/fall2019/notes/11-joins.pdf<i class="fa fa-external-link"></i></span><br>Readings:  Chapter 12.4-12.6</p><p>我们开始学习Operator Execution执行引擎部分。这次学习我们Join是如何被实现的。</p><a id="more"></a><p><img data-src="/images/CMU1544564/Lec11/1.jpg" alt="1.jpg"></p><blockquote><p>The goal of a good database design is to minimize the amount of information repetition. <strong>This is why we compose tables based on normalization theory</strong>. Joins are therefore needed to reconstruct original tables.</p></blockquote><p><img data-src="/images/CMU1544564/Lec11/2.jpg" alt="2.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/3.jpg" alt="3.jpg"></p><h1 id="Join-Operator"><a href="#Join-Operator" class="headerlink" title="Join Operator"></a>Join Operator</h1><p><img data-src="/images/CMU1544564/Lec11/4.jpg" alt="4.jpg"></p><h2 id="Operator-Output"><a href="#Operator-Output" class="headerlink" title="Operator Output"></a>Operator Output</h2><p>Operator Output指join后的结果，需要被传递给关系代数<strong>树</strong>中更高的运算符。</p><p><img data-src="/images/CMU1544564/Lec11/5.jpg" alt="5.jpg"></p><blockquote><p>In reality, contents of output tuples generated by a join operator varies. <strong>It depends on the DBMS’s processing model, storage model, and the query itself:</strong></p></blockquote><h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><blockquote><p>Copy the values for the attributes in the outer and inner tables into tuples <strong>put into an intermediate result table</strong> just for that operator. </p><ul><li>The <strong>advantage</strong> of this approach is that future operators in the query plan <strong>never need to go back to the base tables to get more data</strong>. </li><li>The <strong>disadvantage</strong> is that this <strong>requires more memory to materialize the entire tuple</strong>.</li></ul></blockquote><p>这里的优点和缺点来自一个原因: 复制数据之后，产生的是无关联的副本，但是<strong>复制的时间和空间开销较大。</strong></p><p><img data-src="/images/CMU1544564/Lec11/6.jpg" alt="6.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/7.jpg" alt="7.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/8.jpg" alt="8.jpg"></p><h3 id="Record-IDs"><a href="#Record-IDs" class="headerlink" title="Record IDs"></a>Record IDs</h3><blockquote><p>The DBMS <strong>only copies the join keys along with the record ids of the matching tuples</strong>.</p></blockquote><p><a href="https://cakebytheoceanluo.github.io/2020/03/11/CMU-15445-Lec03/#Record-ids-%E2%80%94-Unique-identifier">Record IDs</a>相当于一个硬盘上的位置</p><p><img data-src="/images/CMU1544564/Lec11/9.jpg" alt="9.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/10.jpg" alt="10.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/11.jpg" alt="11.jpg"></p><p><br><br><br></p><h2 id="Cost-Analysis"><a href="#Cost-Analysis" class="headerlink" title="Cost Analysis"></a>Cost Analysis</h2><blockquote><p><strong>The cost metric</strong> that we are going to use to analyze the different join algorithms will be <strong>the number of disk I/Os used to compute the join</strong>. This includes I/Os incurred by <strong>reading data</strong> from disk as well as <strong>writing intermediate data</strong> out to disk.</p></blockquote><p>在硬盘数据库中，硬盘的I/O操作次数主导了数据库性能。对于Join性能的评价，我们也<strong>只关心I/O的次数</strong>。而不需要特别关心 cache miss, memory access这些细节。</p><p><img data-src="/images/CMU1544564/Lec11/12.jpg" alt="12.jpg"></p><p><br><br><br><br><br></p><h1 id="Join-Algorithms"><a href="#Join-Algorithms" class="headerlink" title="Join Algorithms"></a>Join Algorithms</h1><p><img data-src="/images/CMU1544564/Lec11/13.jpg" alt="13.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/14.jpg" alt="14.jpg"></p><h2 id="Nested-Loop-Join-NLJ"><a href="#Nested-Loop-Join-NLJ" class="headerlink" title="Nested Loop Join - NLJ"></a>Nested Loop Join - NLJ</h2><p>Nested Loop Join, 简称NLJ，是最简单的一种实现，直接参考下图中的伪代码: nested for loop。</p><p>它最简单，性能也最差，适用情况是其他的Join实现都不适合的时候。</p><blockquote><p>At a high-level, this type of join algorithm is comprised of <strong>two nested for loops</strong> that iterate over the tuples in both tables and compares each unique of them. If the tuples match the join predicate, then output them.　<strong>The table in the outer for loop is called the outer table</strong>, while <strong>the table in the inner for loop is called the　inner table</strong>.</p><p>The DBMS will always want to <strong>use the “smaller” table as the outer table</strong>. Smaller can be in terms of the number of tuples or number of pages. The DBMS will also want to buffer as much of the outer table in memory as possible. If possible, leverage an index to find matches in inner table.</p></blockquote><p><img data-src="/images/CMU1544564/Lec11/15.jpg" alt="15.jpg"></p><p><br><br><br></p><h3 id="Stupid-Nested-Loop-Join"><a href="#Stupid-Nested-Loop-Join" class="headerlink" title="Stupid Nested Loop Join"></a>Stupid Nested Loop Join</h3><blockquote><p><strong>For each tuple in the outer table</strong>, compare it with each tuple in the inner table.<br>  This is the worst case scenario where you assume that there is one disk I/O to read each tuple (i.e., there is no caching or access locality).</p></blockquote><p>这个方法只是一种对NLJ的解释，性能角度非常不合理: 没有locality - 对每一个左边的tuple m　都需要连接右侧全部的N个page。</p><p><img data-src="/images/CMU1544564/Lec11/16.jpg" alt="16.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/17.jpg" alt="17.jpg"></p><p><br><br><br></p><h3 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested Loop Join"></a>Block Nested Loop Join</h3><blockquote><p><strong>For each block in the outer table</strong>, fetch each block from the inner table and compare all the tuples in those　two blocks.<br>  This algorithm performs fewer disk access because we scan the inner table for every outer table block instead of for every tuple.</p></blockquote><ul><li><strong>Block 这里指Page</strong></li><li>Block NLJ对当前的Page进行了<strong>最大利用</strong>。对每一个左边的每个page都需要连接右侧全部的N个page。</li></ul><p><img data-src="/images/CMU1544564/Lec11/18.jpg" alt="18.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/19.jpg" alt="19.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/20.jpg" alt="20.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/21.jpg" alt="21.jpg"></p><h4 id="Buffer-Batches"><a href="#Buffer-Batches" class="headerlink" title="Buffer Batches"></a>Buffer Batches</h4><blockquote><p>If the DBMS has B buffers available to compute the join, then it can use B − 2 buffers to scan the outer table.<br>  It will use one buffer to hold a block from the inner table and one buffer to store the output of the join.</p></blockquote><p>如果我们有足够的空间，可以在内存中<strong>缓存B个page</strong>。我们可以做到: 对B-2个左边的pages都需要连接右侧全部的N个page。</p><p><img data-src="/images/CMU1544564/Lec11/22.jpg" alt="22.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/23.jpg" alt="23.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/24.jpg" alt="24.jpg"></p><h3 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested Loop Join"></a>Index Nested Loop Join</h3><blockquote><p>The previous nested loop join algorithms perform poorly because the DBMS has to do a sequential scan to check for a match in the inner table.<br>  But if the database already has <strong>an index for one of the tables on the join key</strong>, then it can use that to speed up the comparison.<br>  <strong>The outer table will be the one without an index. The inner table will be the one with the index.</strong></p></blockquote><ul><li>NLJ之所以非常差的原因是，我们不知道两个表格直接的关系，各自的数据分布。因此只能暴力枚举brute force去完成join。</li><li>如果我们能知道一些数据内部的信息，<strong>比如有一个index，就能加速NLJ</strong>。</li><li>甚至我们不必提前知道信息。数据库估计出普通NLJ非常慢，花时间的话，<strong>可以单独为了这个join,去制作一个Index索引，制作完以后使用它去完成join</strong>。这样流程下来，所需的时间可能比直接普通NLJ更快。这样单独为一个query制作Index的过程可以被称为<strong>on the fly</strong>, 即一个现在进行时的概念。</li><li>课上提到SQL Server在对应情况下会制作一个B+ Tree on the fly。</li></ul><p><img data-src="/images/CMU1544564/Lec11/25.jpg" alt="25.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/26.jpg" alt="26.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/27.jpg" alt="27.jpg"></p><p>如果对S有一个Index, 那么对每一个R的tuple就不比查看整个S表格了，简单的一次Index look up就好。一次look up的时间复杂度取决于index数据结构:</p><ul><li>Hash Table: C = O(1)</li><li>B+ Tree: C = O(log n)</li></ul><h3 id="NLJ总结"><a href="#NLJ总结" class="headerlink" title="NLJ总结"></a>NLJ总结</h3><p><img data-src="/images/CMU1544564/Lec11/28.jpg" alt="28.jpg"></p><p><br><br><br></p><h2 id="Sort-Merge-Join"><a href="#Sort-Merge-Join" class="headerlink" title="Sort-Merge Join"></a>Sort-Merge Join</h2><blockquote><p>The high-level is to sort the two tables on their join key. Then perform a sequential scan on the sorted tables to compute the join. <strong>This algorithm is useful if one or both tables are already sorted on join attribute(s)</strong>.</p><p>The <strong>worst case</strong> scenario for this algorithm is if <strong>the join attribute for all the tuples in both tables contain the same value</strong>. This is very unlikely to happen in real databases.</p></blockquote><p><img data-src="/images/CMU1544564/Lec11/29.jpg" alt="29.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/30.jpg" alt="30.jpg"></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img data-src="/images/CMU1544564/Lec11/31.jpg" alt="31.jpg"></p><p><br></p><h4 id="Phase-1-Sort"><a href="#Phase-1-Sort" class="headerlink" title="Phase #1 - Sort"></a>Phase #1 - Sort</h4><p><img data-src="/images/CMU1544564/Lec11/32.jpg" alt="32.jpg"></p><p><br></p><h4 id="Phase-2-Merge"><a href="#Phase-2-Merge" class="headerlink" title="Phase #2 - Merge"></a>Phase #2 - Merge</h4><p><img data-src="/images/CMU1544564/Lec11/33.jpg" alt="33.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/34.jpg" alt="34.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/35.jpg" alt="35.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/36.jpg" alt="36.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/37.jpg" alt="37.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/38.jpg" alt="38.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/39.jpg" alt="39.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/40.jpg" alt="40.jpg"></p><h5 id="Backtracking-inner-relation"><a href="#Backtracking-inner-relation" class="headerlink" title="Backtracking - inner relation"></a>Backtracking - inner relation</h5><p>如果左侧relation出现数值相同的情况，右侧relation的cursor必须要回去backtracking到相同的数值。</p><p><img data-src="/images/CMU1544564/Lec11/41.jpg" alt="41.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/42.jpg" alt="42.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/43.jpg" alt="43.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/44.jpg" alt="44.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/45.jpg" alt="45.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/46.jpg" alt="46.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/47.jpg" alt="47.jpg"></p><ul><li>实际上图就已经可以停止了，因为R中当前值比S中最大的值还大，不会被连接了。</li></ul><p><img data-src="/images/CMU1544564/Lec11/48.jpg" alt="48.jpg"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img data-src="/images/CMU1544564/Lec11/49.jpg" alt="49.jpg"></p><ul><li>上图中Merge Cost没有考虑backtracking, 因为它和具体左侧表格中相等的数值相关。</li></ul><p><img data-src="/images/CMU1544564/Lec11/50.jpg" alt="50.jpg"></p><p><br><br><br></p><p><img data-src="/images/CMU1544564/Lec11/51.jpg" alt="51.jpg"></p><ul><li>上图中Merge Cost的worst case实际上在现实中不太常见。</li></ul><p><img data-src="/images/CMU1544564/Lec11/52.jpg" alt="52.jpg"></p><ul><li>实际上sort的时间复杂度的大头。</li><li>如果数据已经被排序(在Clustered Index中)了，那么Merge Sort Join会是很好的选择。</li><li>或是输出要求被排序，我们也可以选择Merge Sort Join，因为其他的Join的实现不保证排序。</li></ul><p><br></p><p>下面是另外一个Merge Sort Join的例子(我会在另外一篇未来的文章提到它):</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9kYi5pbi50dW0uZGUvdGVhY2hpbmcvd3MxOTIwL2dydW5kbGFnZW4vTG9lc3VuZzExLnBkZj9sYW5nPWRl" title="https://db.in.tum.de/teaching/ws1920/grundlagen/Loesung11.pdf?lang=de">https://db.in.tum.de/teaching/ws1920/grundlagen/Loesung11.pdf?lang=de<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYi5pbi50dW0uZGUvdGVhY2hpbmcvd3MxNDE1L2dydW5kbGFnZW4vTG9lc3VuZzExX3NvcnRfbWVyZ2Vfam9pbi5wZGY=" title="https://db.in.tum.de/teaching/ws1415/grundlagen/Loesung11_sort_merge_join.pdf">https://db.in.tum.de/teaching/ws1415/grundlagen/Loesung11_sort_merge_join.pdf<i class="fa fa-external-link"></i></span></li></ul><p><br><br><br></p><h2 id="Hash-Join"><a href="#Hash-Join" class="headerlink" title="Hash Join"></a>Hash Join</h2><blockquote><p>The high-level idea of the hash join algorithm is to <strong>use a hash table to split up the tuples into smaller chunks based on their join attribute(s)</strong>. This <strong>reduces the number of comparisons</strong> that the DBMS needs to perform per tuple to compute the join. Hash join can <strong>only be used for equi-joins</strong> on the complete join key.</p></blockquote><p><img data-src="/images/CMU1544564/Lec11/53.jpg" alt="53.jpg"></p><blockquote><p>The <strong>key</strong> in the hash table is the join attributes. The <strong>value</strong> depends on the implementation.</p><p>Since there may be <strong>hash collisions in the hash table</strong>, the DBMS will need to examine the original values of the join attribute(s) to determine whether tuples are truly matching.</p></blockquote><p>注意我们Build和Probe使用的都是同一个hash function h1。</p><p><img data-src="/images/CMU1544564/Lec11/54.jpg" alt="54.jpg"></p><h3 id="Basic-Hash-Join"><a href="#Basic-Hash-Join" class="headerlink" title="Basic Hash Join"></a>Basic Hash Join</h3><h4 id="Phase-1-–-Build"><a href="#Phase-1-–-Build" class="headerlink" title="Phase #1 – Build"></a>Phase #1 – Build</h4><p><img data-src="/images/CMU1544564/Lec11/55.jpg" alt="55.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/56.jpg" alt="56.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/57.jpg" alt="57.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/58.jpg" alt="58.jpg"></p><h4 id="Phase-2-–-Probe"><a href="#Phase-2-–-Probe" class="headerlink" title="Phase #2 – Probe"></a>Phase #2 – Probe</h4><p><img data-src="/images/CMU1544564/Lec11/59.jpg" alt="59.jpg"></p><p><br></p><h3 id="Hash-Table-Contents-amp-Values"><a href="#Hash-Table-Contents-amp-Values" class="headerlink" title="Hash Table Contents &amp; Values"></a>Hash Table Contents &amp; Values</h3><p>Hash Table Values就像前面提到的，需要在具体实现中选择。</p><p><img data-src="/images/CMU1544564/Lec11/60.jpg" alt="60.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/61.jpg" alt="61.jpg"></p><p><br></p><h3 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h3><p>Bloom Filter是一种概率性数据结构，支持insert, lookup。它只需要非常小的存储空间(CPU Cache-line)。</p><p>look up结果:</p><ul><li><strong>true:　数值可能在bloom filter中，可能不在bloom filter中</strong></li><li><strong>false: 数值肯定不在bloom filter中</strong></li></ul><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/Lec11/bf01.png" alt="bf01"></p><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/Lec11/bf02.png" alt="bf02"></p><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/Lec11/bf03.png" alt="bf03"></p><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/Lec11/bf04.png" alt="bf04"></p><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/Lec11/bf05.png" alt="bf05"></p><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/Lec11/bf06.png" alt="bf06"></p><h3 id="Probe-Phase-Optimization"><a href="#Probe-Phase-Optimization" class="headerlink" title="Probe Phase Optimization"></a>Probe Phase Optimization</h3><p>一个优化是: 在正式Probe之前,先在Bloom Filter里面查一下, 这样可以筛选掉绝对不存在的:</p><p><img data-src="/images/CMU1544564/Lec11/62.jpg" alt="62.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/63.jpg" alt="63.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/64.jpg" alt="64.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/65.jpg" alt="65.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/66.jpg" alt="66.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/67.jpg" alt="67.jpg"></p><h3 id="Grace-Hash-Join-Hybrid-Hash-Join-External-Hash-Join"><a href="#Grace-Hash-Join-Hybrid-Hash-Join-External-Hash-Join" class="headerlink" title="Grace Hash Join / Hybrid Hash Join / External Hash Join"></a>Grace Hash Join / Hybrid Hash Join / External Hash Join</h3><blockquote><p>If the DBMS knows the size of the outer table, the join can use a static hash table.<br>  If it does not know the size, then the join has to use a dynamic hash table or allow for overflow pages.</p></blockquote><p><img data-src="/images/CMU1544564/Lec11/68.jpg" alt="68.jpg"></p><blockquote><p><strong>When the tables do not fit on main memory, you do not want the buffer pool manager constantly swapping tables in and out.</strong><br>  The Grace Hash Join is an extension of the basic hash join that is also hashes the inner table into partitions that are written out to disk. The name “Grace” comes from GRACE database machine developed during the 1980s in Japan.</p></blockquote><p><img data-src="/images/CMU1544564/Lec11/69.jpg" alt="69.jpg"></p><blockquote><p>Phase #1 - Build: </p><ul><li>Scan both the outer and inner tables and populate a hash table using the hash function h1 on the join attributes. The hash table’s buckets are written out to disk as needed. </li><li>If a single bucket does not fit in memory, then use <strong>recursive partitioning</strong> with a second hash function h2 (where h1 != h2) to further divide the bucket.</li></ul><p>Phase #2 - Probe: </p><ul><li>For each bucket level, retrieve the corresponding pages for both outer and inner tables. </li><li>Then perform a nested loop join on the tuples in those two pages. The pages will fit in memory, so this join operation will be fast.</li></ul></blockquote><p>Partitioning将可能join的tuple复制到同一个Partition中，这样提高了Locality。我们以后讲高性能HashJoin的时候会重点提这个方法</p><p><img data-src="/images/CMU1544564/Lec11/70.jpg" alt="70.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/71.jpg" alt="71.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/72.jpg" alt="72.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/73.jpg" alt="73.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/74.jpg" alt="74.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/75.jpg" alt="75.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/76.jpg" alt="76.jpg"></p><h4 id="Recursive-Partitioning"><a href="#Recursive-Partitioning" class="headerlink" title="Recursive Partitioning"></a>Recursive Partitioning</h4><p><img data-src="/images/CMU1544564/Lec11/77.jpg" alt="77.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/78.jpg" alt="78.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/79.jpg" alt="79.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/80.jpg" alt="80.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/81.jpg" alt="81.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/82.jpg" alt="82.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/83.jpg" alt="83.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/84.jpg" alt="84.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/85.jpg" alt="85.jpg"></p><p><br><br><br><br><br></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p><img data-src="/images/CMU1544564/Lec11/86.jpg" alt="86.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/87.jpg" alt="87.jpg"></p><p><img data-src="/images/CMU1544564/Lec11/88.jpg" alt="88.jpg"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Join Algorithms - 连接算法&lt;/p&gt;
&lt;p&gt;Slide: &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTkvc2xpZGVzLzExLWpvaW5zLnBkZg==&quot; title=&quot;https://15445.courses.cs.cmu.edu/fall2019/slides/11-joins.pdf&quot;&gt;https://15445.courses.cs.cmu.edu/fall2019/slides/11-joins.pdf&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;Note: &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTkvbm90ZXMvMTEtam9pbnMucGRm&quot; title=&quot;https://15445.courses.cs.cmu.edu/fall2019/notes/11-joins.pdf&quot;&gt;https://15445.courses.cs.cmu.edu/fall2019/notes/11-joins.pdf&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;Readings:  Chapter 12.4-12.6&lt;/p&gt;
&lt;p&gt;我们开始学习Operator Execution执行引擎部分。这次学习我们Join是如何被实现的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CMU-15445" scheme="https://cakebytheoceanluo.github.io/categories/CMU-15445/"/>
    
      <category term="Data Structure" scheme="https://cakebytheoceanluo.github.io/categories/Data-Structure/"/>
    
      <category term="Operator Execution / Query Processing" scheme="https://cakebytheoceanluo.github.io/categories/Operator-Execution-Query-Processing/"/>
    
      <category term="Join" scheme="https://cakebytheoceanluo.github.io/categories/Join/"/>
    
      <category term="Hash Join" scheme="https://cakebytheoceanluo.github.io/categories/Hash-Join/"/>
    
    
      <category term="Join" scheme="https://cakebytheoceanluo.github.io/tags/Join/"/>
    
      <category term="Hash Join" scheme="https://cakebytheoceanluo.github.io/tags/Hash-Join/"/>
    
      <category term="Sort-Merge Join" scheme="https://cakebytheoceanluo.github.io/tags/Sort-Merge-Join/"/>
    
      <category term="Nested Loop Join" scheme="https://cakebytheoceanluo.github.io/tags/Nested-Loop-Join/"/>
    
      <category term="Bloom Filter" scheme="https://cakebytheoceanluo.github.io/tags/Bloom-Filter/"/>
    
      <category term="Late Materialization" scheme="https://cakebytheoceanluo.github.io/tags/Late-Materialization/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode-Algorithm] 15.3-sum</title>
    <link href="https://cakebytheoceanluo.github.io/2020/10/16/Leetcode-Algorithm-15-3-sum/"/>
    <id>https://cakebytheoceanluo.github.io/2020/10/16/Leetcode-Algorithm-15-3-sum/</id>
    <published>2020-10-16T13:02:48.000Z</published>
    <updated>2020-10-27T18:30:46.720Z</updated>
    
    <content type="html"><![CDATA[<p>15.3Sum</p><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? <strong>Find all unique triplets</strong> in the array which gives the sum of zero.</p><p>Note:</p><p>The solution set must not contain duplicate triplets.</p><p>Example:</p><p>Given array nums = [-1, 0, 1, 2, -1, -4],</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><h1 id="解法-双指针-Two-Pointers"><a href="#解法-双指针-Two-Pointers" class="headerlink" title="解法 - 双指针 Two Pointers"></a>解法 - 双指针 Two Pointers</h1><p>关键点：</p><ul><li>题目需要所有三个数字和为0的不重复可能性<ul><li>特例: 三个数全是 0 的情况</li><li>普遍例子: 会有负数和正数共存的情况，至少一个负数和至少一个正数</li></ul></li></ul><p>所以一开始先对这个<code>vector</code>排序, 然后开始我们的<strong>循环</strong>:</p><ul><li>从右开始选择一个负数<code>fix</code>。然后再去找<code>fix</code>右边的邻居<code>left</code>,它的正负性不重要。然后再binary search到对应的<code>right</code>,它必须是正数。然后我们依然用<strong>Two Pointer双指针</strong>的方法，让俩指针<code>left, right</code>相互靠近，去检查是否有我们的解。<ul><li><code>Precondition: fix &lt;= 0, right &gt;= 0</code></li><li>左指针<code>left = fix + 1</code>，右指针 <code>right = binary_search(0 - *fix - *left)</code>，当 <code>*left &lt; *right</code> 时，执行循环：<ul><li>当 <code>*fix + *left + *right == 0</code> ，执行循环，判断左指针和右指针是否和下一位置重复，去除重复解。并同时将 <code>left, right</code> 移到下一<strong>无重复的</strong>位置，寻找新的解；</li><li>若和大于 <code>0</code>，说明 <code>*right</code> 太大，<code>right</code> 左移</li><li>若和小于 <code>0</code>，说明 <code>*left</code> 太小，<code>left</code> 右移</li></ul></li></ul></li><li>循环遍历至<code>fix</code>触碰到第一个正数，这时候停止。</li></ul><p>注意点: </p><ul><li><code>vector</code>中允许出现重复数值，因此<code>fix, left, right</code>在处理数据时　均需要注意重复数值。这个是这题的重点。</li><li>返回的结果中，不能有有重复的结果。我们之前对<code>vector</code>排序，再开始从最小值(头一个元素)开始遍历。考虑上一个注意点，我们不必用 hash table去存储结果。如果在处理数据的时候足够仔细，结果存储在<code>std::vector</code>中(其实也是题目的要求)也一样能完成题目。</li></ul><p><img data-src="https://github.com/MisterBooo/LeetCodeAnimation/raw/master/0015-3Sum/Animation/Animation.gif" alt="Source: https://github.com/MisterBooo/LeetCodeAnimation"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>) <span class="keyword">return</span> {};  <span class="comment">// For test cases.</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());  <span class="comment">// I modify the vector. :D</span></span><br><span class="line">        <span class="keyword">auto</span> fix = nums.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Precondition: fix &lt;= 0, right &gt;= 0</span></span><br><span class="line">        <span class="keyword">while</span> (fix + <span class="number">2</span> &lt; nums.<span class="built_in">end</span>() &amp;&amp; *fix &lt;= <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">auto</span> left = fix + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> complement = <span class="number">0</span> - *fix - *left;</span><br><span class="line">            <span class="comment">// assert(*fix &lt;= *left);</span></span><br><span class="line">            <span class="keyword">if</span> (complement &lt; *left) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// assert(*left &lt;= complement);</span></span><br><span class="line">            <span class="keyword">auto</span> right = <span class="built_in">std</span>::upper_bound(left, nums.<span class="built_in">end</span>(), complement);</span><br><span class="line">            right--;</span><br><span class="line">            <span class="comment">// assert(right &gt;= left);</span></span><br><span class="line">            <span class="keyword">if</span> (*right &lt; <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// fix + left is too large. Thus we stop.</span></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; right &lt; nums.<span class="built_in">end</span>()) {</span><br><span class="line">                <span class="keyword">if</span> (*fix + *left + *right == <span class="number">0</span>) {</span><br><span class="line">                    result.push_back({*fix, *left, *right});</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ignore all duplicates of *left.</span></span><br><span class="line">                    <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right &amp;&amp; *left == *(left + <span class="number">1</span>)) {</span><br><span class="line">                        ++left;</span><br><span class="line">                    }</span><br><span class="line">                    ++left;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ignore all duplicates of *fix.</span></span><br><span class="line">                    <span class="keyword">while</span> (fix + <span class="number">1</span> &lt; left &amp;&amp; *fix == *(fix + <span class="number">1</span>)) {</span><br><span class="line">                        ++fix;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ignore all duplicates of *right.</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right - <span class="number">1</span> &amp;&amp; *right == *(right - <span class="number">1</span>)) {</span><br><span class="line">                        --right;</span><br><span class="line">                    }</span><br><span class="line">                    --right;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (*fix + *left + *right &gt; <span class="number">0</span>) {</span><br><span class="line">                    --right;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    ++left;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            ++fix;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>重点:</p><ul><li><code>auto right = std::upper_bound(left, nums.end(), complement);</code> 基本是一个binary search的实现。查到我们需要处理的最大的值，即最右边并且有必要查看的值。想象这个vector非常大，后面的部分的数值很大，都不需要查看。</li><li><code>std::upper_bound</code>组合<code>r--;</code></li><li>我个人觉可以使用这个binary search。我在下面链接的其他答案没有使用这个点，从头一个元素和最后一个元素开始检查。</li></ul><p>其他小的地方:</p><ul><li><code>assert</code>好像会影响Leetcode上面runtime, memory usage的性能。</li></ul><p>复杂度:</p><ul><li>时间复杂度: $O(N^2)$<ul><li>数组排序 $O(NlogN)$, 遍历数组$O(n)$, 双指针遍历 $O(n)$, 总体复杂度为 $O(NlogN) + O(n) * O(n) = O(n^2)$</li></ul></li><li>空间复杂度：$O(N)$<ul><li>数组排序: $O(logN)$ (assumed quick-sort)</li></ul></li></ul><p><br></p><p>引用和推荐的阅读：</p><p><span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2FsZ29yaXRobS9sb3dlcl9ib3VuZA==" title="https://en.cppreference.com/w/cpp/algorithm/lower_bound">https://en.cppreference.com/w/cpp/algorithm/lower_bound<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2FsZ29yaXRobS91cHBlcl9ib3VuZA==" title="https://en.cppreference.com/w/cpp/algorithm/upper_bound">https://en.cppreference.com/w/cpp/algorithm/upper_bound<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvM3N1bQ==" title="https://leetcode.com/problems/3sum">https://leetcode.com/problems/3sum<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvM3N1bS9zb2x1dGlvbi9zYW4tc2h1LXpoaS1oZS1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=" title="https://leetcode-cn.com/problems/3sum/solution/san-shu-zhi-he-by-leetcode-solution/">https://leetcode-cn.com/problems/3sum/solution/san-shu-zhi-he-by-leetcode-solution/<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01pc3RlckJvb28vTGVldENvZGVBbmltYXRpb24vYmxvYi9tYXN0ZXIvMDAxNS0zU3VtL0FydGljbGUvMDAxNS0zU3VtLm1k" title="https://github.com/MisterBooo/LeetCodeAnimation/blob/master/0015-3Sum/Article/0015-3Sum.md">https://github.com/MisterBooo/LeetCodeAnimation/blob/master/0015-3Sum/Article/0015-3Sum.md<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01pc3RlckJvb28vTGVldENvZGVBbmltYXRpb24vYmxvYi9tYXN0ZXIvMDAxNS0zU3VtL0FydGljbGUvMDAxNS0zU3VtMi5tZA==" title="https://github.com/MisterBooo/LeetCodeAnimation/blob/master/0015-3Sum/Article/0015-3Sum2.md">https://github.com/MisterBooo/LeetCodeAnimation/blob/master/0015-3Sum/Article/0015-3Sum2.md<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xlb1Npcml1cy9sZWV0Y29kZV9zb2x1dGlvbnMvYmxvYi9tYXN0ZXIvMDAxNV8zU3VtL1NvbHV0aW9uMS5jcHA=" title="https://github.com/LeoSirius/leetcode_solutions/blob/master/0015_3Sum/Solution1.cpp">https://github.com/LeoSirius/leetcode_solutions/blob/master/0015_3Sum/Solution1.cpp<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZWNuL0ludGVydmlldy9ibG9iL21hc3Rlci9kb2NzL0FsZ29yaXRobS9MZWV0Y29kZS9DJTJCJTJCLzAwMTUuXzNzdW0ubWQ=" title="https://github.com/apachecn/Interview/blob/master/docs/Algorithm/Leetcode/C%2B%2B/0015._3sum.md">https://github.com/apachecn/Interview/blob/master/docs/Algorithm/Leetcode/C%2B%2B/0015._3sum.md<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhb2VsL2xlZXRjb2RlL2Jsb2IvbWFzdGVyL2FsZ29yaXRobXMvY3BwLzNTdW0vM1N1bS5jcHA=" title="https://github.com/haoel/leetcode/blob/master/algorithms/cpp/3Sum/3Sum.cpp">https://github.com/haoel/leetcode/blob/master/algorithms/cpp/3Sum/3Sum.cpp<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2F6bDM5Nzk4NTg1Ni9sZWV0Y29kZS9ibG9iL21hc3Rlci9wcm9ibGVtcy8xNS4zc3VtLm1k" title="https://github.com/azl397985856/leetcode/blob/master/problems/15.3sum.md">https://github.com/azl397985856/leetcode/blob/master/problems/15.3sum.md<i class="fa fa-external-link"></i></span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;15.3Sum&lt;/p&gt;
&lt;p&gt;Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? &lt;strong&gt;Find all unique triplets&lt;/strong&gt; in the array which gives the sum of zero.&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;p&gt;The solution set must not contain duplicate triplets.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;p&gt;Given array nums = [-1, 0, 1, 2, -1, -4],&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;A solution set is:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-1, 0, 1],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-1, -1, 2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://cakebytheoceanluo.github.io/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="https://cakebytheoceanluo.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://cakebytheoceanluo.github.io/tags/Leetcode/"/>
    
      <category term="C++" scheme="https://cakebytheoceanluo.github.io/tags/C/"/>
    
      <category term="Two Pointers" scheme="https://cakebytheoceanluo.github.io/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>[CMU-15445]Homework2_18Fall</title>
    <link href="https://cakebytheoceanluo.github.io/2020/10/15/CMU-15445-Homework2-18Fall/"/>
    <id>https://cakebytheoceanluo.github.io/2020/10/15/CMU-15445-Homework2-18Fall/</id>
    <published>2020-10-15T13:46:49.000Z</published>
    <updated>2020-10-15T13:56:11.875Z</updated>
    
    <content type="html"><![CDATA[<p>2018 Fall: HOMEWORK #2 - Indexes</p><p>Homework: <span class="exturl" data-url="aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTgvZmlsZXMvaHcyLWNsZWFuLnBkZg==" title="https://15445.courses.cs.cmu.edu/fall2018/files/hw2-clean.pdf">https://15445.courses.cs.cmu.edu/fall2018/files/hw2-clean.pdf<i class="fa fa-external-link"></i></span><br>Solution: <span class="exturl" data-url="aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTgvZmlsZXMvaHcyLXNvbHMucGRm" title="https://15445.courses.cs.cmu.edu/fall2018/files/hw2-sols.pdf">https://15445.courses.cs.cmu.edu/fall2018/files/hw2-sols.pdf<i class="fa fa-external-link"></i></span></p><a id="more"></a><h1 id="Question-1-Extendible-Hashing"><a href="#Question-1-Extendible-Hashing" class="headerlink" title="Question 1: Extendible Hashing"></a>Question 1: Extendible Hashing</h1><h2 id="a"><a href="#a" class="headerlink" title="a)"></a>a)</h2><div class="table-container"><table><thead><tr><th>Number</th><th>binary</th></tr></thead><tbody><tr><td>8</td><td>0b 1000</td></tr><tr><td>16</td><td>0b10000</td></tr><tr><td>4</td><td>0b 0100</td></tr><tr><td>3</td><td>0b 0011</td></tr><tr><td>11</td><td>0b 1011</td></tr><tr><td>12</td><td>0b 1100</td></tr><tr><td>18</td><td>0b10010</td></tr></tbody></table></div><h3 id="Insert-8"><a href="#Insert-8" class="headerlink" title="Insert 8"></a>Insert 8</h3><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/1_01.png" alt=""></p><h3 id="Insert-16"><a href="#Insert-16" class="headerlink" title="Insert 16"></a>Insert 16</h3><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/1_02.png" alt=""></p><h3 id="Insert-4"><a href="#Insert-4" class="headerlink" title="Insert 4"></a>Insert 4</h3><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/1_03.png" alt=""></p><h3 id="Insert-3"><a href="#Insert-3" class="headerlink" title="Insert 3"></a>Insert 3</h3><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/1_04.png" alt=""></p><h3 id="Insert-11"><a href="#Insert-11" class="headerlink" title="Insert 11"></a>Insert 11</h3><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/1_05.png" alt=""></p><h3 id="Insert-12"><a href="#Insert-12" class="headerlink" title="Insert 12"></a>Insert 12</h3><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/1_06.png" alt=""></p><h3 id="Insert-18"><a href="#Insert-18" class="headerlink" title="Insert 18"></a>Insert 18</h3><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/1_07.png" alt=""></p><h2 id="b"><a href="#b" class="headerlink" title="b)"></a>b)</h2><div class="table-container"><table><thead><tr><th>Number</th><th>binary</th></tr></thead><tbody><tr><td>20</td><td>0b10100</td></tr><tr><td>2</td><td>0b 0010</td></tr><tr><td>26</td><td>0b11010</td></tr><tr><td>18</td><td>0b10010</td></tr><tr><td>3</td><td>0b 0011</td></tr><tr><td>15</td><td>0b 1111</td></tr><tr><td>7</td><td>0b 0111</td></tr><tr><td>14</td><td>0b 1110</td></tr><tr><td>-</td><td>-</td></tr><tr><td>28</td><td>0b11100</td></tr><tr><td>30</td><td>0b11110</td></tr><tr><td>4</td><td>0b 0100</td></tr><tr><td>8</td><td>0b 1000</td></tr><tr><td>34</td><td>0b100010</td></tr></tbody></table></div><h3 id="Insert-28"><a href="#Insert-28" class="headerlink" title="Insert 28"></a>Insert 28</h3><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/1_08.png" alt=""></p><h3 id="Insert-30"><a href="#Insert-30" class="headerlink" title="Insert 30"></a>Insert 30</h3><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/1_09.png" alt=""></p><h3 id="Insert-4-1"><a href="#Insert-4-1" class="headerlink" title="Insert 4"></a>Insert 4</h3><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/1_10.png" alt=""></p><h3 id="Insert-8-1"><a href="#Insert-8-1" class="headerlink" title="Insert 8"></a>Insert 8</h3><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/1_11.png" alt=""></p><h3 id="Insert-34"><a href="#Insert-34" class="headerlink" title="Insert 34"></a>Insert 34</h3><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/1_12.png" alt=""></p><h2 id="c"><a href="#c" class="headerlink" title="c)"></a>c)</h2><h3 id="Delete-14"><a href="#Delete-14" class="headerlink" title="Delete 14"></a>Delete 14</h3><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/1_13.png" alt=""></p><h3 id="Delete-20"><a href="#Delete-20" class="headerlink" title="Delete 20"></a>Delete 20</h3><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/1_14.png" alt=""></p><hr><h1 id="Question-2-Linear-Hashing"><a href="#Question-2-Linear-Hashing" class="headerlink" title="Question 2: Linear Hashing"></a>Question 2: Linear Hashing</h1><h2 id="a-1"><a href="#a-1" class="headerlink" title="a)"></a>a)</h2><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/2_02.png" alt=""></p><h2 id="b-1"><a href="#b-1" class="headerlink" title="b)"></a>b)</h2><h3 id="Insert-12-1"><a href="#Insert-12-1" class="headerlink" title="Insert 12"></a>Insert 12</h3><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/2_03.png" alt=""></p><h3 id="Insert-13"><a href="#Insert-13" class="headerlink" title="Insert 13"></a>Insert 13</h3><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/2_04.png" alt=""></p><h3 id="Insert-19"><a href="#Insert-19" class="headerlink" title="Insert 19"></a>Insert 19</h3><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/2_05.png" alt=""></p><hr><h1 id="Question-3-B-Tree"><a href="#Question-3-B-Tree" class="headerlink" title="Question 3: B+ Tree"></a>Question 3: B+ Tree</h1><h2 id="a-2"><a href="#a-2" class="headerlink" title="a)"></a>a)</h2><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/3_01.png" alt=""></p><h2 id="b-2"><a href="#b-2" class="headerlink" title="b)"></a>b)</h2><h3 id="Insert-10"><a href="#Insert-10" class="headerlink" title="Insert 10"></a>Insert 10</h3><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/3_02.png" alt=""></p><h3 id="Insert-10-18"><a href="#Insert-10-18" class="headerlink" title="Insert (10), 18"></a>Insert (10), 18</h3><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/3_03.png" alt=""></p><h3 id="Delete-11"><a href="#Delete-11" class="headerlink" title="Delete 11"></a>Delete 11</h3><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/3_04.png" alt=""></p><h3 id="Delete-31"><a href="#Delete-31" class="headerlink" title="Delete 31"></a>Delete 31</h3><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/3_05.png" alt=""></p><h2 id="c-1"><a href="#c-1" class="headerlink" title="c)"></a>c)</h2><h3 id="Insert-28-1"><a href="#Insert-28-1" class="headerlink" title="Insert 28"></a>Insert 28</h3><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/3_06.png" alt=""></p><h3 id="Delete-3"><a href="#Delete-3" class="headerlink" title="Delete 3"></a>Delete 3</h3><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/3_07.png" alt=""></p><h1 id="Question-4-Skip-Lists-and-Radix-Tree"><a href="#Question-4-Skip-Lists-and-Radix-Tree" class="headerlink" title="Question 4: Skip Lists and Radix Tree"></a>Question 4: Skip Lists and Radix Tree</h1><h2 id="a-3"><a href="#a-3" class="headerlink" title="a)"></a>a)</h2><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/4_01.png" alt=""></p><h2 id="b-3"><a href="#b-3" class="headerlink" title="b)"></a>b)</h2><p><strong>Not valid</strong></p><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/4_02.png" alt=""></p><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall18/4_03.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018 Fall: HOMEWORK #2 - Indexes&lt;/p&gt;
&lt;p&gt;Homework: &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTgvZmlsZXMvaHcyLWNsZWFuLnBkZg==&quot; title=&quot;https://15445.courses.cs.cmu.edu/fall2018/files/hw2-clean.pdf&quot;&gt;https://15445.courses.cs.cmu.edu/fall2018/files/hw2-clean.pdf&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;Solution: &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTgvZmlsZXMvaHcyLXNvbHMucGRm&quot; title=&quot;https://15445.courses.cs.cmu.edu/fall2018/files/hw2-sols.pdf&quot;&gt;https://15445.courses.cs.cmu.edu/fall2018/files/hw2-sols.pdf&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Access Methods" scheme="https://cakebytheoceanluo.github.io/categories/Access-Methods/"/>
    
      <category term="CMU-15445" scheme="https://cakebytheoceanluo.github.io/categories/CMU-15445/"/>
    
      <category term="Hash Table" scheme="https://cakebytheoceanluo.github.io/categories/Hash-Table/"/>
    
      <category term="Data Structure" scheme="https://cakebytheoceanluo.github.io/categories/Data-Structure/"/>
    
      <category term="Indexing" scheme="https://cakebytheoceanluo.github.io/categories/Indexing/"/>
    
      <category term="Skip List" scheme="https://cakebytheoceanluo.github.io/categories/Skip-List/"/>
    
      <category term="Trie / Radix Tree" scheme="https://cakebytheoceanluo.github.io/categories/Trie-Radix-Tree/"/>
    
    
      <category term="B Tree" scheme="https://cakebytheoceanluo.github.io/tags/B-Tree/"/>
    
      <category term="Indexing" scheme="https://cakebytheoceanluo.github.io/tags/Indexing/"/>
    
      <category term="Dynamic Hashing Scheme" scheme="https://cakebytheoceanluo.github.io/tags/Dynamic-Hashing-Scheme/"/>
    
      <category term="Extendible Hashing" scheme="https://cakebytheoceanluo.github.io/tags/Extendible-Hashing/"/>
    
      <category term="Linear Hashing" scheme="https://cakebytheoceanluo.github.io/tags/Linear-Hashing/"/>
    
      <category term="Trie / Radix Tree" scheme="https://cakebytheoceanluo.github.io/tags/Trie-Radix-Tree/"/>
    
      <category term="Skip List" scheme="https://cakebytheoceanluo.github.io/tags/Skip-List/"/>
    
  </entry>
  
  <entry>
    <title>[CMU-15445]Lec10 Sorting &amp; Aggregations - 排序与聚合</title>
    <link href="https://cakebytheoceanluo.github.io/2020/10/10/CMU-15445-Lec10/"/>
    <id>https://cakebytheoceanluo.github.io/2020/10/10/CMU-15445-Lec10/</id>
    <published>2020-10-10T10:41:24.000Z</published>
    <updated>2020-10-17T11:59:34.801Z</updated>
    
    <content type="html"><![CDATA[<p>Sorting &amp; Aggregations - 排序与聚合</p><p>Slide: <span class="exturl" data-url="aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTkvc2xpZGVzLzEwLXNvcnRpbmcucGRm" title="https://15445.courses.cs.cmu.edu/fall2019/slides/10-sorting.pdf">https://15445.courses.cs.cmu.edu/fall2019/slides/10-sorting.pdf<i class="fa fa-external-link"></i></span><br>Note: <span class="exturl" data-url="aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTkvbm90ZXMvMTAtc29ydGluZy5wZGY=" title="https://15445.courses.cs.cmu.edu/fall2019/notes/10-sorting.pdf">https://15445.courses.cs.cmu.edu/fall2019/notes/10-sorting.pdf<i class="fa fa-external-link"></i></span><br>Readings:  Chapter 12.4-12.5</p><p>我们开始学习Operator Execution执行引擎部分。这次我们关注排序和聚合是如何在数据库中完成的。同时也思考，如果内存容量不够，如何进行排序和聚合。</p><a id="more"></a><p><img data-src="/images/CMU1544564/Lec10/1.jpg" alt="1.jpg"></p><p><img data-src="/images/CMU1544564/Lec10/3.jpg" alt="3.jpg"></p><ul><li>Logical Query Plan:<br><img data-src="/images/CMU1544564/Lec10/4.jpg" alt="4.jpg"></li></ul><p><img data-src="/images/CMU1544564/Lec10/5.jpg" alt="5.jpg"></p><p><img data-src="/images/CMU1544564/Lec10/6.jpg" alt="6.jpg"></p><p><br><br><br></p><h1 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h1><blockquote><p>We need sorting because in the relation model, <strong>tuples in a table have no specific order Sorting</strong> is (potentially) used in <em>ORDER BY</em>, <em>GROUP BY</em>, <em>JOIN</em>, and <em>DISTINCT</em> operators. </p><p>We can accelerate sorting using a <strong>clustered B+tree</strong> by scanning the leaf nodes from left to right. This is a bad idea, however, if we use an unclustered B+tree to sort because it causes a lot of I/O reads (random access through pointer chasing). </p></blockquote><p><img data-src="/images/CMU1544564/Lec10/7.jpg" alt="7.jpg"></p><ul><li>Bulkloading: <a href="https://cakebytheoceanluo.github.io/2020/03/19/CMU-15445-Lec07/#Bulk-Insert">aka. Bulk Insert</a></li></ul><p><br><br><br><br><br></p><p><img data-src="/images/CMU1544564/Lec10/8.jpg" alt="8.jpg"></p><blockquote><ul><li>If the data that we need to sort fits in memory, then the DBMS can use a standard sorting algorithms (e.g., quicksort). </li><li>If the data does not fit, then the DBMS needs to use external sorting that is able to spill to disk as needed and prefers sequential over random I/O.</li></ul></blockquote><ul><li><strong>quick-sort只适用在纯内存环境下</strong>. 因为如果在磁盘环境下，每次选取pivot, 不管我们是随机选还是选中位数(median)都非常可能会引起random I/O甚至page fault。这会导致性能非常低效。</li></ul><p><br></p><h2 id="External-Merge-Sort"><a href="#External-Merge-Sort" class="headerlink" title="External Merge Sort"></a>External Merge Sort</h2><blockquote><p>Divide-and-conquer sorting algorithm that splits the data set into separate <em>runs</em> and then sorts them individually. It can spill runs to disk as needed then read them back in one at a time.</p></blockquote><p><img data-src="/images/CMU1544564/Lec10/9.jpg" alt="9.jpg"></p><ul><li>Phase #1 – Sorting: Sort <strong>small chunks of data (them called as a run)</strong> that fit in main memory, and then write back to disk.</li><li>Phase #2 – Merge: Combine sorted sub-files into a larger single file.</li></ul><p><br></p><h2 id="2-Way-External-Merge-Sort"><a href="#2-Way-External-Merge-Sort" class="headerlink" title="2-Way External Merge Sort"></a>2-Way External Merge Sort</h2><p><img data-src="/images/CMU1544564/Lec10/10.jpg" alt="10.jpg"></p><ul><li><em>N</em>, <em>B</em>都是已知的。</li></ul><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Pass-0-Sort-Runs-in-place-sort"><a href="#Pass-0-Sort-Runs-in-place-sort" class="headerlink" title="Pass #0: Sort Runs (in-place sort)"></a>Pass #0: Sort Runs (in-place sort)</h4><blockquote><p>Each sorted set of pages is called <strong>a run</strong>.</p></blockquote><p>下面几张图代表Pass #0: </p><ul><li>每次从硬盘上读入<em>B</em>个page进入我们固定大小的内存缓存区。在内存中对它们排序，再将这些数量的page写回硬盘。(<em>例子中写回在硬盘的另外一个位置，但是实际上可以写回同一个位置，去覆盖未排序的数据。</em>) 这样的一次 <strong>读入-排序-写回</strong> 循环，被我们称为run。</li></ul><p><img data-src="/images/CMU1544564/Lec10/11.jpg" alt="11.jpg"></p><p><img data-src="/images/CMU1544564/Lec10/12.jpg" alt="12.jpg"></p><p><img data-src="/images/CMU1544564/Lec10/13.jpg" alt="13.jpg"></p><p><img data-src="/images/CMU1544564/Lec10/14.jpg" alt="14.jpg"></p><p><img data-src="/images/CMU1544564/Lec10/15.jpg" alt="15.jpg"></p><p><br></p><h4 id="Pass-1-2-3…-Merge-Runs-non-in-place-sort"><a href="#Pass-1-2-3…-Merge-Runs-non-in-place-sort" class="headerlink" title="Pass #1,2,3…: Merge Runs (non in-place sort)"></a>Pass #1,2,3…: Merge Runs (non in-place sort)</h4><p>然后开始merge， 我们需要<strong>至少3个page</strong>在内存中: </p><ul><li>从硬盘上读入进入2个page，然后剩一个page是缓存最终排序结果并准备写入硬盘。</li></ul><p><img data-src="/images/CMU1544564/Lec10/16.jpg" alt="16.jpg"></p><p><img data-src="/images/CMU1544564/Lec10/17.jpg" alt="17.jpg"></p><p><img data-src="/images/CMU1544564/Lec10/18.jpg" alt="18.jpg"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img data-src="/images/CMU1544564/Lec10/19.jpg" alt="19.jpg"></p><ul><li>上图中Number of passes中的<code>1</code>: <em>Pass #0</em></li><li>上图中Total I/O cost中的<code>2</code>: 每次循环都需要从硬盘中<em>读出和写入</em>进硬盘。</li></ul><p><img data-src="/images/CMU1544564/Lec10/20.jpg" alt="20.jpg"></p><ul><li>上图中，即使有更多的缓存区，也不能帮助2-Way External Merge Sort， 最后造成的I/O次数依然是一样的。</li></ul><p><br><br><br></p><h2 id="Double-Buffering-Optimization"><a href="#Double-Buffering-Optimization" class="headerlink" title="Double Buffering Optimization"></a>Double Buffering Optimization</h2><blockquote><p><strong>Prefetch the next run in the background</strong> and store it in a second buffer while the system is processing the current run. <strong>This reduces the wait time for I/O requests</strong> at each step by continuously utilizing the disk.</p></blockquote><p>Double Buffering Optimization主要让I/O一直在操作，一个线程在排序的时候，<strong>另外一个线程</strong>依然在做 async I/O - prefetching。这样让硬盘一直在进行I/O操作, 隐藏 <strong>hide the I/O latency</strong>.</p><p>下图中的例子中:</p><ul><li>Memory中上面的是当前sort的run (Page#1)</li><li>Memory中下面那个是prefetching的用于下一次的run (Page#2)</li></ul><p><img data-src="/images/CMU1544564/Lec10/21.jpg" alt="21.jpg"></p><p><br><br><br></p><h2 id="General-K-way-Merge-Sort"><a href="#General-K-way-Merge-Sort" class="headerlink" title="General (K-way) Merge Sort"></a>General (K-way) Merge Sort</h2><p><img data-src="/images/CMU1544564/Lec10/24.jpg" alt="24.jpg"></p><ul><li>上图中Number of passes中的<code>1+...</code>: <em>Pass #0</em></li><li>上图中的<code>B-1</code>: Merge时B-1个input page, 1个output page</li></ul><p><img data-src="/images/CMU1544564/Lec10/25.jpg" alt="25.jpg"></p><ul><li>Pass #0: Sort (inplace sort)</li><li>Pass #1,2,3: Merge (non in-place sort)</li></ul><p><strong>有一点优化的点: 我们可以在在内存里面缓存每次run的(min, max)这个对，这样有助于排序skewed的数据。</strong></p><p><br></p><p>External Sort的更多资料 (以后会额外写博客):</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9kYi5pbi50dW0uZGUvdGVhY2hpbmcvc3MxOS9tb2Rlcm5kYnMvY2hhcHRlcjEucGRmP2xhbmc9ZGU=" title="https://db.in.tum.de/teaching/ss19/moderndbs/chapter1.pdf?lang=de">Database Implementation For Modern Hardware, Lec01<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYi5pbi50dW0uZGUvdGVhY2hpbmcvc3MxOS9tb2Rlcm5kYnMvZXh0ZXJuYWwtc29ydC5wZGY/bGFuZz1kZQ==" title="https://db.in.tum.de/teaching/ss19/moderndbs/external-sort.pdf?lang=de">Database Implementation For Modern Hardware, Exercise01<i class="fa fa-external-link"></i></span></li></ul><p><br><br><br><br><br></p><h2 id="Using-B-Tree-For-Sorting-Clustered-B-Tree"><a href="#Using-B-Tree-For-Sorting-Clustered-B-Tree" class="headerlink" title="　Using B+ Tree For Sorting - Clustered B+ Tree"></a>　Using B+ Tree For Sorting - Clustered B+ Tree</h2><p>如果SQL要求一个字段key，而这个字段正好是B+ Tree索引的key。那么这个顺序我们可以直接从索引中获得。</p><p><img data-src="/images/CMU1544564/Lec10/26.jpg" alt="26.jpg"></p><h3 id="Case1-Clustered-B-Tree"><a href="#Case1-Clustered-B-Tree" class="headerlink" title="Case1: Clustered B+ Tree"></a>Case1: Clustered B+ Tree</h3><p><strong>Physical location of tuple on page matches sort order in the index.</strong></p><p><img data-src="/images/CMU1544564/Lec10/27.jpg" alt="27.jpg"></p><h3 id="Case2-Un-clustered-B-Tree"><a href="#Case2-Un-clustered-B-Tree" class="headerlink" title="Case2: Un-clustered B+ Tree"></a>Case2: Un-clustered B+ Tree</h3><p>这个情况非常不好，下一个tuple很可能被存储在另外一个无关联的page, 寻找它变成了一次random I/O。如果每一次寻找一个tuple,　都会是一次random I/O的话，性能会非常垃圾。</p><p><img data-src="/images/CMU1544564/Lec10/28.jpg" alt="28.jpg"></p><p><br><br><br><br><br><br><br></p><h1 id="Aggregations"><a href="#Aggregations" class="headerlink" title="Aggregations"></a>Aggregations</h1><blockquote><p>An aggregation operator in a query plan collapses the values of one or more tuples into a single scalar value.</p></blockquote><p>Aggregations对应SQL中的关键字:</p><ul><li><code>MIN, MAX, COUNT ...</code></li><li><code>GROUP BY</code></li><li><code>DISTINCT</code></li><li>…</li></ul><p><img data-src="/images/CMU1544564/Lec10/29.jpg" alt="29.jpg"></p><h2 id="Sorting-Aggregate"><a href="#Sorting-Aggregate" class="headerlink" title="Sorting Aggregate"></a>Sorting Aggregate</h2><blockquote><p>The DBMS first sorts the tuples on the <em>GROUP BY</em> key(s). It can use either an in-memory sorting algorithm if everything fits in the buffer pool (e.g., quicksort) or the external merge sort algorithm if the size of the data exceeds memory.<br>The DBMS then performs a sequential scan over the sorted data to compute the aggregation. The output of the operator will be sorted on the keys.</p></blockquote><p><img data-src="/images/CMU1544564/Lec10/30.jpg" alt="30.jpg"></p><p><img data-src="/images/CMU1544564/Lec10/31.jpg" alt="31.jpg"></p><p><img data-src="/images/CMU1544564/Lec10/32.jpg" alt="32.jpg"></p><p><br></p><p><img data-src="/images/CMU1544564/Lec10/33.jpg" alt="33.jpg"></p><ul><li>Sorting is expensive: $O(n\log{n})$</li></ul><p><br></p><h2 id="Hashing-Aggregate"><a href="#Hashing-Aggregate" class="headerlink" title="Hashing Aggregate"></a>Hashing Aggregate</h2><blockquote><p>Hashing can be <strong>computationally cheaper</strong> than sorting for computing aggregations. The DBMS populates an ephemeral hash table as it scans the table. For each record, check whether there is already an entry in the hash table and perform the appropriate modification.</p></blockquote><p><img data-src="/images/CMU1544564/Lec10/34.jpg" alt="34.jpg"></p><h3 id="External-Hashing-Aggregate"><a href="#External-Hashing-Aggregate" class="headerlink" title="External Hashing Aggregate"></a>External Hashing Aggregate</h3><p><img data-src="/images/CMU1544564/Lec10/35.jpg" alt="35.jpg"></p><ul><li>整体上hashing会是更好的办法，它可以<strong>最小化sequential I/O的次数</strong>。获得一个page, 使用完所有上面的tuple, 然后再也不会用到它。接下来去使用下一个page。</li><li>(实际上这里的操作很像Hash Join with Hash Partitions)</li></ul><h4 id="Phase-1-–-Partition"><a href="#Phase-1-–-Partition" class="headerlink" title="Phase #1 – Partition"></a>Phase #1 – Partition</h4><blockquote><p>Use a hash function h1 to split tuples into partitions on disk based on target hash key. This will put all tuples that match into the same partition. The DBMS spills partitions to disk via output buffers.</p></blockquote><p><img data-src="/images/CMU1544564/Lec10/36.jpg" alt="36.jpg"></p><p><img data-src="/images/CMU1544564/Lec10/37.jpg" alt="37.jpg"></p><p>Partition结束之后，各个B-1个buffer里面的tuple都有相同的hash value。通过Partition我们获得这种<strong>locality</strong>，我们获得了不同的buffer, 而<strong>每一个buffer page里面的值有非常大的可能是相同，或者相似，或者有相似特征的</strong>。</p><h4 id="Phase-2-–-ReHash"><a href="#Phase-2-–-ReHash" class="headerlink" title="Phase #2 – ReHash"></a>Phase #2 – ReHash</h4><p>前后两个hash function: h1, h2不需要相同。</p><p><img data-src="/images/CMU1544564/Lec10/38.jpg" alt="38.jpg"></p><p><img data-src="/images/CMU1544564/Lec10/39.jpg" alt="39.jpg"></p><p><img data-src="/images/CMU1544564/Lec10/40.jpg" alt="40.jpg"></p><p><img data-src="/images/CMU1544564/Lec10/41.jpg" alt="41.jpg"></p><p><img data-src="/images/CMU1544564/Lec10/42.jpg" alt="42.jpg"></p><p><img data-src="/images/CMU1544564/Lec10/43.jpg" alt="43.jpg"></p><p><img data-src="/images/CMU1544564/Lec10/44.jpg" alt="44.jpg"></p><p><img data-src="/images/CMU1544564/Lec10/45.jpg" alt="45.jpg"></p><p>结束之后(以及在ReHash的过程中)，中间的hash table是暂时的，如果用完了它，就可以直接销毁/释放。</p><p><br></p><h4 id="Hashing-Summarization"><a href="#Hashing-Summarization" class="headerlink" title="Hashing Summarization"></a>Hashing Summarization</h4><p><img data-src="/images/CMU1544564/Lec10/46.jpg" alt="46.jpg"></p><p>Hashing Summarization可以帮助我们计算最后的Aggregate Function: 比如<code>sum, count, avg, min, max</code>。下面例子中的<code>value</code>是<code>(running count, running sum)</code>:</p><p><img data-src="/images/CMU1544564/Lec10/47.jpg" alt="47.jpg"></p><p><img data-src="/images/CMU1544564/Lec10/48.jpg" alt="48.jpg"></p><p><img data-src="/images/CMU1544564/Lec10/49.jpg" alt="49.jpg"></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img data-src="/images/CMU1544564/Lec10/50.jpg" alt="50.jpg"></p><p><br><br><br><br><br></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p><img data-src="/images/CMU1544564/Lec10/51.jpg" alt="51.jpg"></p><p><img data-src="/images/CMU1544564/Lec10/57.jpg" alt="57.jpg"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Sorting &amp;amp; Aggregations - 排序与聚合&lt;/p&gt;
&lt;p&gt;Slide: &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTkvc2xpZGVzLzEwLXNvcnRpbmcucGRm&quot; title=&quot;https://15445.courses.cs.cmu.edu/fall2019/slides/10-sorting.pdf&quot;&gt;https://15445.courses.cs.cmu.edu/fall2019/slides/10-sorting.pdf&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;Note: &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTkvbm90ZXMvMTAtc29ydGluZy5wZGY=&quot; title=&quot;https://15445.courses.cs.cmu.edu/fall2019/notes/10-sorting.pdf&quot;&gt;https://15445.courses.cs.cmu.edu/fall2019/notes/10-sorting.pdf&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;Readings:  Chapter 12.4-12.5&lt;/p&gt;
&lt;p&gt;我们开始学习Operator Execution执行引擎部分。这次我们关注排序和聚合是如何在数据库中完成的。同时也思考，如果内存容量不够，如何进行排序和聚合。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CMU-15445" scheme="https://cakebytheoceanluo.github.io/categories/CMU-15445/"/>
    
      <category term="Sorting" scheme="https://cakebytheoceanluo.github.io/categories/Sorting/"/>
    
      <category term="Aggregation" scheme="https://cakebytheoceanluo.github.io/categories/Aggregation/"/>
    
      <category term="Operator Execution / Query Processing" scheme="https://cakebytheoceanluo.github.io/categories/Operator-Execution-Query-Processing/"/>
    
    
      <category term="B Tree" scheme="https://cakebytheoceanluo.github.io/tags/B-Tree/"/>
    
      <category term="Clustered Index" scheme="https://cakebytheoceanluo.github.io/tags/Clustered-Index/"/>
    
      <category term="External Sort" scheme="https://cakebytheoceanluo.github.io/tags/External-Sort/"/>
    
      <category term="Sorting Aggregate" scheme="https://cakebytheoceanluo.github.io/tags/Sorting-Aggregate/"/>
    
      <category term="Hashing Aggregate" scheme="https://cakebytheoceanluo.github.io/tags/Hashing-Aggregate/"/>
    
      <category term="External Hashing Aggregate" scheme="https://cakebytheoceanluo.github.io/tags/External-Hashing-Aggregate/"/>
    
  </entry>
  
  <entry>
    <title>[CMU-15445]Homework2_19Fall</title>
    <link href="https://cakebytheoceanluo.github.io/2020/10/08/CMU-15445-Homework2-19Fall/"/>
    <id>https://cakebytheoceanluo.github.io/2020/10/08/CMU-15445-Homework2-19Fall/</id>
    <published>2020-10-08T18:04:03.000Z</published>
    <updated>2020-10-15T13:48:13.988Z</updated>
    
    <content type="html"><![CDATA[<p>2019 Fall: HOMEWORK #2 - Indexes</p><p>Homework: <span class="exturl" data-url="aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTkvZmlsZXMvaHcyLWNsZWFuLnBkZg==" title="https://15445.courses.cs.cmu.edu/fall2019/files/hw2-clean.pdf">https://15445.courses.cs.cmu.edu/fall2019/files/hw2-clean.pdf<i class="fa fa-external-link"></i></span><br>Solution: <span class="exturl" data-url="aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTkvZmlsZXMvaHcyLXNvbHMucGRm" title="https://15445.courses.cs.cmu.edu/fall2019/files/hw2-sols.pdf">https://15445.courses.cs.cmu.edu/fall2019/files/hw2-sols.pdf<i class="fa fa-external-link"></i></span></p><a id="more"></a><h1 id="Question-1-Cuckoo-Hashing"><a href="#Question-1-Cuckoo-Hashing" class="headerlink" title="Question 1: Cuckoo Hashing"></a>Question 1: Cuckoo Hashing</h1><h2 id="a-Insert-12-10"><a href="#a-Insert-12-10" class="headerlink" title="a) Insert 12, 10"></a>a) Insert 12, 10</h2><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall19/1_1.png" alt=""></p><h2 id="b-Delete-14-Insert-8"><a href="#b-Delete-14-Insert-8" class="headerlink" title="b) Delete 14, Insert 8"></a>b) Delete 14, Insert 8</h2><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall19/1_2.png" alt=""></p><h2 id="c-Insert-28"><a href="#c-Insert-28" class="headerlink" title="c) Insert 28"></a>c) Insert 28</h2><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall19/1_3.png" alt=""></p><h2 id="d"><a href="#d" class="headerlink" title="d)"></a>d)</h2><script type="math/tex; mode=display">6 = 0b\;0110, h_1(6)=01, h_2(6)=10</script><hr><h1 id="Question-2-B-Tree"><a href="#Question-2-B-Tree" class="headerlink" title="Question 2: B+Tree"></a>Question 2: B+Tree</h1><h2 id="a-Insert-10"><a href="#a-Insert-10" class="headerlink" title="a) Insert 10"></a>a) Insert 10</h2><p>这次insertion会让我们的树增加一个level</p><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall19/2_1.png" alt=""></p><h2 id="b"><a href="#b" class="headerlink" title="b)"></a>b)</h2><p>下图中 我注出了四个指针:</p><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall19/2_2.png" alt=""></p><h2 id="c-Delete-23"><a href="#c-Delete-23" class="headerlink" title="c) Delete 23"></a>c) Delete 23</h2><p>这次deletion会让我们的树减少一个level</p><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall19/2_3.png" alt=""></p><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall19/2_4.png" alt=""></p><h2 id="d-Insert-4-Delete-11"><a href="#d-Insert-4-Delete-11" class="headerlink" title="d) Insert 4, Delete 11"></a>d) Insert 4, Delete 11</h2><p>实际上我们有两种答案</p><ul><li>第一种如下图: 从左兄弟节点中获取7, 更新父节点也为7</li><li>第二种: 从右兄弟节点中获取13, 更新父节点为17</li></ul><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall19/2_5.png" alt=""></p><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall19/2_6.png" alt=""></p><hr><h1 id="Question-3-Extendible-Hashing"><a href="#Question-3-Extendible-Hashing" class="headerlink" title="Question 3: Extendible Hashing"></a>Question 3: Extendible Hashing</h1><ul><li>$t$: global depth</li><li>$t’$: local depth</li></ul><h2 id="a-Insert-15-3-7-14"><a href="#a-Insert-15-3-7-14" class="headerlink" title="a) Insert 15, 3, 7, 14"></a>a) Insert 15, 3, 7, 14</h2><div class="table-container"><table><thead><tr><th>Number</th><th>binary</th><th>inverse binary</th></tr></thead><tbody><tr><td>15</td><td>0b 1111</td><td>1111</td></tr><tr><td>3</td><td>0b 0011</td><td>1100</td></tr><tr><td>7</td><td>0b 0111</td><td>1110</td></tr><tr><td>14</td><td>0b 1110</td><td>0111</td></tr></tbody></table></div><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall19/3_1.png" alt=""></p><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall19/3_2.png" alt=""></p><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall19/3_3.png" alt=""></p><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall19/3_4.png" alt=""></p><h2 id="b-Insert-1-9-23-11-17"><a href="#b-Insert-1-9-23-11-17" class="headerlink" title="b) Insert 1, 9, 23, 11, 17"></a>b) Insert 1, 9, 23, 11, 17</h2><div class="table-container"><table><thead><tr><th>Number</th><th>binary</th><th>inverse binary</th></tr></thead><tbody><tr><td>1</td><td>0b 0001</td><td>1000</td></tr><tr><td>9</td><td>0b 1001</td><td>1001</td></tr><tr><td>23</td><td>0b10111</td><td>11101</td></tr><tr><td>11</td><td>0b 1011</td><td>1101</td></tr><tr><td>17</td><td>0b 10001</td><td>10001</td></tr></tbody></table></div><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall19/3_5.png" alt=""></p><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall19/3_6.png" alt=""></p><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall19/3_7.png" alt=""></p><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall19/3_8.png" alt=""></p><h2 id="c-Delete-2-7-13-15-29"><a href="#c-Delete-2-7-13-15-29" class="headerlink" title="c) Delete 2, 7, 13, 15, 29"></a>c) Delete 2, 7, 13, 15, 29</h2><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall19/3_9.png" alt=""></p><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall19/3_10.png" alt=""></p><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall19/3_11.png" alt=""></p><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall19/3_12.png" alt=""></p><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall19/3_13.png" alt=""></p><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall19/3_14.png" alt=""></p><h1 id="Question-4-Suffix-Trees"><a href="#Question-4-Suffix-Trees" class="headerlink" title="Question 4: Suffix Trees"></a>Question 4: Suffix Trees</h1><p>这题非常简单, 不做额外解释</p><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/HW2_Fall19/4_1.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019 Fall: HOMEWORK #2 - Indexes&lt;/p&gt;
&lt;p&gt;Homework: &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTkvZmlsZXMvaHcyLWNsZWFuLnBkZg==&quot; title=&quot;https://15445.courses.cs.cmu.edu/fall2019/files/hw2-clean.pdf&quot;&gt;https://15445.courses.cs.cmu.edu/fall2019/files/hw2-clean.pdf&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;Solution: &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTkvZmlsZXMvaHcyLXNvbHMucGRm&quot; title=&quot;https://15445.courses.cs.cmu.edu/fall2019/files/hw2-sols.pdf&quot;&gt;https://15445.courses.cs.cmu.edu/fall2019/files/hw2-sols.pdf&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Access Methods" scheme="https://cakebytheoceanluo.github.io/categories/Access-Methods/"/>
    
      <category term="CMU-15445" scheme="https://cakebytheoceanluo.github.io/categories/CMU-15445/"/>
    
      <category term="Hash Table" scheme="https://cakebytheoceanluo.github.io/categories/Hash-Table/"/>
    
      <category term="Data Structure" scheme="https://cakebytheoceanluo.github.io/categories/Data-Structure/"/>
    
      <category term="Indexing" scheme="https://cakebytheoceanluo.github.io/categories/Indexing/"/>
    
      <category term="Trie / Radix Tree" scheme="https://cakebytheoceanluo.github.io/categories/Trie-Radix-Tree/"/>
    
    
      <category term="B Tree" scheme="https://cakebytheoceanluo.github.io/tags/B-Tree/"/>
    
      <category term="Indexing" scheme="https://cakebytheoceanluo.github.io/tags/Indexing/"/>
    
      <category term="Dynamic Hashing Scheme" scheme="https://cakebytheoceanluo.github.io/tags/Dynamic-Hashing-Scheme/"/>
    
      <category term="Extendible Hashing" scheme="https://cakebytheoceanluo.github.io/tags/Extendible-Hashing/"/>
    
      <category term="Trie / Radix Tree" scheme="https://cakebytheoceanluo.github.io/tags/Trie-Radix-Tree/"/>
    
      <category term="Cuckoo Hashing" scheme="https://cakebytheoceanluo.github.io/tags/Cuckoo-Hashing/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode-Algorithm] 167.two-sum-sorted</title>
    <link href="https://cakebytheoceanluo.github.io/2020/10/06/Leetcode-Algorithm-167-two-sum-sorted/"/>
    <id>https://cakebytheoceanluo.github.io/2020/10/06/Leetcode-Algorithm-167-two-sum-sorted/</id>
    <published>2020-10-06T21:57:02.000Z</published>
    <updated>2020-10-18T20:31:14.898Z</updated>
    
    <content type="html"><![CDATA[<p>167.Two Sum II - Input array is sorted</p><p>Given an array of integers that is already <strong>sorted in ascending order</strong>, find two numbers such that they add up to a specific target number.</p><p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.</p><p><strong>Note:</strong></p><ul><li>Your returned answers (both index1 and index2) are not zero-based.</li><li>You may assume that each input would have <em>exactly</em> one solution and you may not use the <em>same</em> element twice.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: numbers = [2,7,11,15], target = 9</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><h1 id="解法-双指针-Two-Pointer"><a href="#解法-双指针-Two-Pointer" class="headerlink" title="解法 - 双指针 Two Pointer"></a>解法 - 双指针 Two Pointer</h1><p>关键点：</p><ul><li>已经排列</li><li><p>保证一定有解</p></li><li><p>初始化左指针 <code>l</code> 指向数组起始，初始化右指针 <code>r</code>使用binary search找到对应的位置。</p></li><li>处理<code>l</code>和<code>r</code>之前的元素:<ul><li>和等于 target ，则返回 <code>l + 1</code> 和 <code>r + 1</code>。（注意以 1 为起始下标）</li><li>和大于<code>target</code>, <code>r</code>左移, 使得和变小    </li><li>和小于<code>target</code>, <code>l</code>右移, 使得和变大   </li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="comment">// assert(std::is_sorted(numbers.begin(), numbers.end()) &amp;&amp; "The pre-condition is the vector is sorted!");</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> max_complement = target - numbers.front();</span><br><span class="line">        <span class="keyword">auto</span> r = <span class="built_in">std</span>::upper_bound(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), max_complement);</span><br><span class="line">        r--;</span><br><span class="line">        <span class="comment">// assert(r != numbers.end() &amp;&amp; "We assume there exists at least one two-sum pair!");</span></span><br><span class="line">        <span class="keyword">auto</span> l = numbers.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) {</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> result = *l + *r;</span><br><span class="line">            <span class="keyword">if</span> (result == target) {</span><br><span class="line">                <span class="keyword">return</span> {<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::distance(numbers.<span class="built_in">begin</span>(), l)) + <span class="number">1</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::distance(numbers.<span class="built_in">begin</span>(), r)) + <span class="number">1</span>};</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (result &gt; target) {</span><br><span class="line">                r--;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                l++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> {};</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>重点:</p><ul><li><code>auto r = std::upper_bound(numbers.begin(), numbers.end(), max_complement);</code> 基本是一个binary search的实现。查到我们需要处理的最大的值，即最右边并且有必要查看的值。想象这个vector非常大，后面的部分的数值都大于<code>target</code>。</li><li><code>std::upper_bound</code>组合<code>r--;</code>是因为有如下的test: <code>[0, 0, 3, 4]\n0</code>需要输出<code>[0, 1]</code>。 我原来使用的只是<code>std::lower_bound</code>，卡在如上test。这俩函数实际非常类似，时间复杂度也是一样的。</li><li>我个人觉可以使用这个binary search。我在下面链接的其他答案没有使用这个点，从头一个元素和最后一个元素开始检查。</li></ul><p>其他小的地方:</p><ul><li><code>assert</code>好像会影响Leetcode上面runtime, memory usage的性能。</li></ul><p>复杂度:</p><ul><li>时间复杂度：$O(N \log{N})$</li><li>空间复杂度：$O(1)$</li></ul><p><br></p><p>引用和推荐的阅读：</p><p><span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2FsZ29yaXRobS9sb3dlcl9ib3VuZA==" title="https://en.cppreference.com/w/cpp/algorithm/lower_bound">https://en.cppreference.com/w/cpp/algorithm/lower_bound<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2FsZ29yaXRobS91cHBlcl9ib3VuZA==" title="https://en.cppreference.com/w/cpp/algorithm/upper_bound">https://en.cppreference.com/w/cpp/algorithm/upper_bound<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdHdvLXN1bS1paS1pbnB1dC1hcnJheS1pcy1zb3J0ZWQ=" title="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted">https://leetcode.com/problems/two-sum-ii-input-array-is-sorted<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdHdvLXN1bS1paS1pbnB1dC1hcnJheS1pcy1zb3J0ZWQvZGlzY3Vzcy81MTI1My9BLXNpbXBsZS1PKG4pLXNvbHV0aW9u" title="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/discuss/51253/A-simple-O(n)-solution">https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/discuss/51253/A-simple-O(n)-solution<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhb2VsL2xlZXRjb2RlL2Jsb2IvbWFzdGVyL2FsZ29yaXRobXMvY3BwL3R3b1N1bS90d29TdW0uSUkuY3Bw" title="https://github.com/haoel/leetcode/blob/master/algorithms/cpp/twoSum/twoSum.II.cpp">https://github.com/haoel/leetcode/blob/master/algorithms/cpp/twoSum/twoSum.II.cpp<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01pc3RlckJvb28vTGVldENvZGVBbmltYXRpb24vYmxvYi9tYXN0ZXIvMDE2Ny1Ud28tU3VtLUlJLUlucHV0LWFycmF5LWlzLXNvcnRlZC9BcnRpY2xlLzAxNjctVHdvLVN1bS1JSS1JbnB1dC1hcnJheS1pcy1zb3J0ZWQubWQ=" title="https://github.com/MisterBooo/LeetCodeAnimation/blob/master/0167-Two-Sum-II-Input-array-is-sorted/Article/0167-Two-Sum-II-Input-array-is-sorted.md">https://github.com/MisterBooo/LeetCodeAnimation/blob/master/0167-Two-Sum-II-Input-array-is-sorted/Article/0167-Two-Sum-II-Input-array-is-sorted.md<i class="fa fa-external-link"></i></span></p><ul><li>不使用binary search:<br><img data-src="https://github.com/MisterBooo/LeetCodeAnimation/raw/master/0167-Two-Sum-II-Input-array-is-sorted/Animation/Animation.gif" alt="Demo 引用自 https://github.com/MisterBooo/LeetCodeAnimation "></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;167.Two Sum II - Input array is sorted&lt;/p&gt;
&lt;p&gt;Given an array of integers that is already &lt;strong&gt;sorted in ascending order&lt;/strong&gt;, find two numbers such that they add up to a specific target number.&lt;/p&gt;
&lt;p&gt;The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Your returned answers (both index1 and index2) are not zero-based.&lt;/li&gt;
&lt;li&gt;You may assume that each input would have &lt;em&gt;exactly&lt;/em&gt; one solution and you may not use the &lt;em&gt;same&lt;/em&gt; element twice.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: numbers = [2,7,11,15], target = 9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: [1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://cakebytheoceanluo.github.io/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="https://cakebytheoceanluo.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://cakebytheoceanluo.github.io/tags/Leetcode/"/>
    
      <category term="C++" scheme="https://cakebytheoceanluo.github.io/tags/C/"/>
    
      <category term="Two Pointers" scheme="https://cakebytheoceanluo.github.io/tags/Two-Pointers/"/>
    
      <category term="Binary Search" scheme="https://cakebytheoceanluo.github.io/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode-Algorithm] 1.two-sum</title>
    <link href="https://cakebytheoceanluo.github.io/2020/10/06/Leetcode-Algorithm-1-two-sum/"/>
    <id>https://cakebytheoceanluo.github.io/2020/10/06/Leetcode-Algorithm-1-two-sum/</id>
    <published>2020-10-06T20:44:14.000Z</published>
    <updated>2020-10-18T20:01:39.109Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Two Sum</li></ol><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p><p>Example:<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></tbody></table></figure><p></p><a id="more"></a><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="Brute-Force-暴力枚举"><a href="#Brute-Force-暴力枚举" class="headerlink" title="Brute Force 暴力枚举"></a>Brute Force 暴力枚举</h2><p>利用两层 for 循环来遍历每个元素，并查找满足条件的目标元素。这个方法不缓存(cache)任何信息，也不使用任何数据结构来帮助。</p><ul><li>时间复杂度为 $O(N^2)$</li><li>空间复杂度为 $O(1)$</li></ul><p>伪代码如下:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foreach(item1 in nums) {</span><br><span class="line">    foreach(item2 in nums){</span><br><span class="line">        if (item1 + item2 == target) {</span><br><span class="line">            return result;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="使用Hash-table-哈希表"><a href="#使用Hash-table-哈希表" class="headerlink" title="使用Hash table 哈希表"></a>使用Hash table 哈希表</h2><p>用hash table记录已经遍历过的数字及其对应的索引值。这样就hash table就缓存(cache)了处理过的元素，然后处理新元素的时候，也需要看一下这些被缓存过的以前的元素。</p><p>关键点</p><ul><li>求和转换为求差</li><li>Hash table: Key是对应的差， Value是对应元素的index位置</li><li>理论上Hash table的lookup查找是在 $O(1)$</li></ul><p>这样我们<strong>遍历一次</strong>这个数组就能知道是否存在two sum, 每处理一个数组元素都存储在hash table里面:</p><ul><li>时间复杂度：$O(N)$</li><li>空间复杂度：$O(N)$</li><li>我看很多人的实现是遍历两次<code>std::vector&lt;int&gt;&amp; nums</code>， 实际上大可不必。在算法或者数据结构中，single-pass也是一个重要的<strong>卖点</strong>。自然一次遍历能结束的事情，何必需要多次遍历呢？第二次遍历非常可能会出现Cache Miss甚至是Last Level Cache Miss, 这自然不是好事情。对于这个single-pass， 见下面的Demo:</li></ul><p><img data-src="https://github.com/MisterBooo/LeetCodeAnimation/blob/master/0001-Two-Sum/Animation/Animation.gif?raw=true" alt="Demo 引用自 https://github.com/MisterBooo/LeetCodeAnimation "></p><ul><li>另外我看很多人的实现<strong>多次</strong>使用hash table的lookup， 也没有必要。</li><li>C++ <code>std::unordered_map&lt;Key,Value&gt;</code>的lookup具体是实现存在于: <code>find()</code>, <code>count()</code>, subscript operator<code>[]</code>, <code>at()</code>, <code>equal_range()</code>。C++20对这个部分还会继续增加: <a href="https://en.cppreference.com/w/cpp/container/unordered_map/contains" target="_blank" rel="noopener"><code>contains()</code></a>。:D</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">size_t</span>&gt; <span class="built_in">map</span>;  <span class="comment">// complement -&gt; index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="comment">/// The complement as value to find!</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">map</span>.<span class="built_in">find</span>(complement);</span><br><span class="line">            <span class="keyword">if</span> (it != <span class="built_in">map</span>.<span class="built_in">end</span>()) {</span><br><span class="line">                <span class="comment">/// Found the two sum pair.</span></span><br><span class="line">                <span class="comment">/// The first value index: i.</span></span><br><span class="line">                <span class="comment">/// The second value index: map[complement].</span></span><br><span class="line">                <span class="keyword">return</span> {<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(i), <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(it-&gt;second)};</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">/// Insert into hash table.</span></span><br><span class="line">                <span class="comment">/// The element at index i can provide num[i] as complement for others.</span></span><br><span class="line">                <span class="built_in">map</span>.emplace(nums[i], i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> {};</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>最后实际上这个题目(实际上)很类似数据库的执行引擎-算子部分, two sum这个操作是一种<span class="exturl" data-url="aHR0cHM6Ly9kYi5pbi50dW0uZGUvdGVhY2hpbmcvc3MyMC9tb2Rlcm5kYnMvY2hhcHRlcjUucGRmP2xhbmc9ZGU=" title="https://db.in.tum.de/teaching/ss20/moderndbs/chapter5.pdf?lang=de">Set-Oriented Processing<i class="fa fa-external-link"></i></span>。</p><p>然后还有一题: <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdHdvLXN1bS1paS1pbnB1dC1hcnJheS1pcy1zb3J0ZWQ=" title="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted">two-sum-ii-input-array-is-sorted<i class="fa fa-external-link"></i></span> 让这俩题变得更加数据库 更加Set-Oriented Processing。甚至有点像Hash Join, Sort-Merge Join的变型。(自然不是equi join, 我私以为是 $ R \bowtie_{r.n + s.n = target} S$， 在这个具体例子里面$R, S$的$n$是<code>std::vector&lt;int&gt;&amp; nums</code>)。 这个思路下，这就更是一个数据库题了。唯一不太对的地方是，我们 <strong>只需要一个结果(一个tuple)</strong> 而已，而不是所有的two sum pair。 :D</p><p>如果我想写一个真正的two sum算子, 给出<strong>所有</strong>存在的two sum pair，我们甚至可以使用iterator model里面的接口: <code>open()</code>, <code>next()</code>, <code>close()</code>去完成这个算子的任务。参考<span class="exturl" data-url="aHR0cHM6Ly9kYi5pbi50dW0uZGUvdGVhY2hpbmcvc3MyMC9tb2Rlcm5kYnMvY2hhcHRlcjUucGRmP2xhbmc9ZGXjgII6RA==" title="https://db.in.tum.de/teaching/ss20/moderndbs/chapter5.pdf?lang=de。:D">https://db.in.tum.de/teaching/ss20/moderndbs/chapter5.pdf?lang=de。:D<i class="fa fa-external-link"></i></span></p><p><br></p><p>引用和推荐的阅读：</p><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdHdvLXN1bQ==" title="https://leetcode.com/problems/two-sum">https://leetcode.com/problems/two-sum<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdHdvLXN1bQ==" title="https://leetcode-cn.com/problems/two-sum">https://leetcode-cn.com/problems/two-sum<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01pc3RlckJvb28vTGVldENvZGVBbmltYXRpb24=" title="https://github.com/MisterBooo/LeetCodeAnimation">https://github.com/MisterBooo/LeetCodeAnimation<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdHdvLXN1bS9zb2x1dGlvbi9saWFuZy1zaHUtemhpLWhlLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==" title="https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/">https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0N5QzIwMTgvQ1MtTm90ZXMvYmxvYi9tYXN0ZXIvbm90ZXMvTGVldGNvZGUlMjAlRTklQTIlOTglRTglQTclQTMlMjAtJTIwJUU1JThGJThDJUU2JThDJTg3JUU5JTkyJTg4Lm1kIzEtJUU2JTlDJTg5JUU1JUJBJThGJUU2JTk1JUIwJUU3JUJCJTg0JUU3JTlBJTg0LXR3by1zdW0=" title="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8F%8C%E6%8C%87%E9%92%88.md#1-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84-two-sum">https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8F%8C%E6%8C%87%E9%92%88.md#1-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84-two-sum<i class="fa fa-external-link"></i></span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Two Sum&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.&lt;br&gt;You may assume that each input would have exactly one solution, and you may not use the same element twice.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Given nums = [2, 7, 11, 15], target = 9,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Because nums[0] + nums[1] = 2 + 7 = 9,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return [0, 1].&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://cakebytheoceanluo.github.io/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="https://cakebytheoceanluo.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://cakebytheoceanluo.github.io/tags/Leetcode/"/>
    
      <category term="C++" scheme="https://cakebytheoceanluo.github.io/tags/C/"/>
    
      <category term="Hash Table" scheme="https://cakebytheoceanluo.github.io/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>[CMU-15445]Lec09 Index Concurrency Control - 索引并发控制</title>
    <link href="https://cakebytheoceanluo.github.io/2020/10/04/CMU-15445-Lec09/"/>
    <id>https://cakebytheoceanluo.github.io/2020/10/04/CMU-15445-Lec09/</id>
    <published>2020-10-04T19:18:51.000Z</published>
    <updated>2020-10-04T19:30:40.011Z</updated>
    
    <content type="html"><![CDATA[<p>Index Concurrency Control - 索引并发控制</p><p>Slide: <span class="exturl" data-url="aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTkvc2xpZGVzLzA5LWluZGV4Y29uY3VycmVuY3kucGRm" title="https://15445.courses.cs.cmu.edu/fall2019/slides/09-indexconcurrency.pdf">https://15445.courses.cs.cmu.edu/fall2019/slides/09-indexconcurrency.pdf<i class="fa fa-external-link"></i></span><br>Note: <span class="exturl" data-url="aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTkvbm90ZXMvMDktaW5kZXhjb25jdXJyZW5jeS5wZGY=" title="https://15445.courses.cs.cmu.edu/fall2019/notes/09-indexconcurrency.pdf">https://15445.courses.cs.cmu.edu/fall2019/notes/09-indexconcurrency.pdf<i class="fa fa-external-link"></i></span><br>Readings:  Chapter 15.10</p><p>我们在之前的课程中已经学了一些数据库中的索引数据结构，主要有Hash Table和B+树。我们已经了解过它们中的操作，性能，使用范围。这次我们对它们做并发控制的研究 - 并发能给数据库带来很大的性能提升。绝大多数的数据库(以及数据库组件)都需要做到多线程，来提高性能。</p><a id="more"></a><p><img data-src="/images/CMU1544564/Lec09/1.jpg" alt="1.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/3.jpg" alt="3.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/4.jpg" alt="4.jpg"></p><ul><li>上图中:</li><li>Logical Correctness: 指这个数据结构在并发的读出与写入都是正确的。即数据结构逻辑角度。<blockquote><p>This means that the thread is able to read values that it should be allowed to read.</p></blockquote></li><li>Physical Correctness: 指并发过程中，不能造成Segment Fault等内存不安全的操作。即代码正确性角度(当然也可以称为硬件角度)。<blockquote><p>This means that there are not pointers in our data structure that will cause a thread to read invalid memory locations.</p></blockquote></li></ul><p><br></p><p><img data-src="/images/CMU1544564/Lec09/5.jpg" alt="5.jpg"></p><h1 id="Latch"><a href="#Latch" class="headerlink" title="Latch"></a>Latch</h1><h2 id="Lock-vs-Latch"><a href="#Lock-vs-Latch" class="headerlink" title="Lock vs. Latch"></a>Lock vs. Latch</h2><p>我们在数据库的语境下比较Lock和Latch。</p><ul><li>Lock特指transaction事务中的事务锁，由事务锁的协议提供， 比如Two-Phase Locking――2PL。</li><li>Latch指程序或伪程序层面，对critical section部分代码线程安全的控制类。比如互斥锁mutex。它往往是或者象征着<br>代码的类，比如<code>std::mutex</code>。</li></ul><p>更多的细节参考下面两页课件，这部分总结得非常好:</p><p><img data-src="/images/CMU1544564/Lec09/6.jpg" alt="6.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/7.jpg" alt="7.jpg"></p><ul><li>A Survey of B-Tree Locking Techniques - Goetz Graefe :<span class="exturl" data-url="aHR0cHM6Ly8xNTcyMS5jb3Vyc2VzLmNzLmNtdS5lZHUvc3ByaW5nMjAxOS9wYXBlcnMvMDYtaW5kZXhlcy9hMTYtZ3JhZWZlLnBkZg==" title="https://15721.courses.cs.cmu.edu/spring2019/papers/06-indexes/a16-graefe.pdf">https://15721.courses.cs.cmu.edu/spring2019/papers/06-indexes/a16-graefe.pdf<i class="fa fa-external-link"></i></span></li></ul><h2 id="Latch-Modes"><a href="#Latch-Modes" class="headerlink" title="Latch Modes"></a>Latch Modes</h2><p><img data-src="/images/CMU1544564/Lec09/8.jpg" alt="8.jpg"></p><h2 id="Latch-Implementations"><a href="#Latch-Implementations" class="headerlink" title="Latch Implementations"></a>Latch Implementations</h2><p>这部分内容属于系统编程和操作系统。</p><blockquote><p>The underlying primitive that we can use to implement a latch is through <strong>an atomic compare-and-swap (CAS) instruction</strong> that modern CPUs provide. With this, <strong>a thread can check the contents of a memory location to see whether it has a certain value. If it does, then the CPU will swap the old value with a new one. Otherwise the memory location remains unmodified.</strong></p><p>There are several approaches to implementing a latch in a DBMS. Each approach have different tradeoffs in terms of engineering complexity and runtime performance. These test-and-set steps are performed atomically (i.e., no other thread can update the value after one thread checks it but before it updates it).</p></blockquote><ul><li>test-and-set: 指assembly汇编的 <code>TSL RAX, [LOCK]</code></li><li>compare-and-swap (CAS): 指assembly汇编的 <code>CMPXCHG &lt;MEM&gt;, RBX</code></li></ul><h3 id="Blocking-OS-Mutex"><a href="#Blocking-OS-Mutex" class="headerlink" title="Blocking OS Mutex"></a>Blocking OS Mutex</h3><blockquote><p>Use the OS built-in mutex infrastructure as a latch. The <strong>futex</strong> (fast user-space mutex) is comprised of (1) a spin latch in user-space and (2) a OS-level mutex. If the DBMS can acquire the user-space latch, then the latch is set. It appears as a single latch to the DBMS even though it contains two internal latches. If the DBMS fails to acquire the user-space latch, then it goes down into the kernel and tries to acquire a more expensive mutex. If the DBMS fails to acquire this second mutex, then the thread notifies the OS that it is<br>blocked on the lock and then it is descheduled.</p><p><strong>OS mutex is generally a bad idea inside of DBMSs as it is managed by OS and has large overhead.</strong></p><ul><li><strong>Advantages</strong>: Simple to use and requires no additional coding in DBMS.</li><li><strong>Disadvantages</strong>: Expensive and non-scalable (about 25 ns per lock/unlock invocation) because of <strong>OS scheduling</strong>.</li></ul></blockquote><p><img data-src="/images/CMU1544564/Lec09/9.jpg" alt="9.jpg"></p><h3 id="Test-and-Set-Spin-Latch-TAS"><a href="#Test-and-Set-Spin-Latch-TAS" class="headerlink" title="Test-and-Set Spin Latch (TAS)"></a>Test-and-Set Spin Latch (TAS)</h3><blockquote><p><strong>Spin latches</strong> are a more efficient alternative to an OS mutex as it is controlled by the DBMSs. A spin latch is essentially <strong>a location in memory that threads try to update (e.g., setting a boolean value to true)</strong>. A thread performs CAS to attempt to update the memory location. <strong>If it cannot, then it spins in a while loop forever trying to update it.</strong></p><ul><li><strong>Advantages</strong>: Latch/unlatch operations are <strong>efficient (single instruction to lock/unlock)</strong>.</li><li><strong>Disadvantages</strong>: Not scalable nor cache friendly because with multiple threads, the CAS instructions will be executed multiple times in different threads. These wasted instructions will pile up in high contention environments; the threads look busy to the OS even though they are not doing useful work. <strong>This leads to cache coherence problems because threads are polling cache lines on other CPUs.</strong></li></ul></blockquote><p><img data-src="/images/CMU1544564/Lec09/10.jpg" alt="10.jpg"></p><p>另外针对这个while循环，我们可以从中做决定:</p><ul><li>Retry: 如果等待的时间不长，继续等待</li><li>Yield, Abort: 如果等待的时间很长，直接放弃等待。做其他的事情，做完以后资源可能就空闲了。</li></ul><h3 id="Reader-Writer-Latches"><a href="#Reader-Writer-Latches" class="headerlink" title="Reader-Writer Latches"></a>Reader-Writer Latches</h3><blockquote><p>Mutexes and Spin Latches do not differentiate between reads / writes (i.e., they <strong>do not support different modes</strong>). We need a way to allow for concurrent reads, so if the application has heavy reads it will have better performance because readers can share resources instead of waiting.<br>A Reader-Writer Latch <strong>allows a latch to be held in either read or write mode</strong>. It keeps track of how many threads hold the latch and are waiting to acquire the latch in each mode.</p><ul><li>Example: This is implemented on top of Spin Latches.</li><li><strong>Advantages</strong>: Allows for concurrent readers.</li><li><strong>Disadvantages</strong>: The DBMS has to manage read/write queues to avoid starvation. Larger storage overhead than Spin Latches due to additional meta-data.</li></ul></blockquote><p>下面的图示中，我们能看到读写锁会记录:</p><ul><li>正在读的数量</li><li>正在写与否(0或1)</li><li>等待读的数量</li><li>等待写的数量</li></ul><p><img data-src="/images/CMU1544564/Lec09/11.jpg" alt="11.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/12.jpg" alt="12.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/13.jpg" alt="13.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/14.jpg" alt="14.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/15.jpg" alt="15.jpg"></p><ul><li>上图情况是有一个读和一个写在等，目前锁模式的读。后面可能发生如下两种情况:<ul><li>可能1: 读的锁不等待，直接和其他两个线程一起读。这样会让写线程一直等，如果一直有新的读线程生成并<em>插队</em>的话。即 读线程优先。</li><li>可能2: 读的锁需要等待写线程的完成。这样会让本可以共享的三次读操作不能同时完成。即 写线程优先。</li></ul></li><li>具体是哪一种应对方式需要看锁的具体实现，也需要看程序中是并行读还是并行写多，需要给谁优先权。</li></ul><p>推荐论文: <span class="exturl" data-url="aHR0cHM6Ly9kYi5pbi50dW0uZGUvfmJvZXR0Y2hlci9sb2NraW5nLnBkZg==" title="https://db.in.tum.de/~boettcher/locking.pdf">Scalable and Robust Latches for Database Systems, Böttcher et al.<i class="fa fa-external-link"></i></span></p><p><br><br><br><br><br></p><h1 id="Hash-Table-Latching"><a href="#Hash-Table-Latching" class="headerlink" title="Hash Table Latching"></a>Hash Table Latching</h1><blockquote><p>It is <strong>easy</strong> to support concurrent access in a <strong>static hash table</strong> due to the limited ways threads access the data structure. For example, <strong>all threads move in the same direction when moving from slot to the next (i.e., top-down). Threads also only access a single page/slot at a time.</strong> Thus,<strong> deadlocks are not possible</strong> in this situation because no two threads could be competing for latches held by the other. <strong>To resize the table, take a global latch on the entire table (i.e., in the header page).</strong></p></blockquote><p>这部分中我们主要讨论static hash scheme中的linear probing hashing。</p><blockquote><p>Latching in a dynamic hashing scheme (e.g., extendible) is slightly more complicated because there is more shared state to update, but the general approach is the same.</p></blockquote><p><img data-src="/images/CMU1544564/Lec09/16.jpg" alt="16.jpg"></p><p><br></p><p><img data-src="/images/CMU1544564/Lec09/17.jpg" alt="17.jpg"></p><blockquote><ul><li><strong>Page Latches</strong>: This <strong>decreases parallelism</strong> because potentially only one thread can access a page at a time, but <strong>accessing multiple slots in a page will be fast</strong> because a thread only has to acquire a single latch.</li><li><strong>Slot Latches</strong>: This <strong>increases parallelism</strong> because <strong>two threads can access different slots in the same page</strong>. But it <strong>increases the storage and computational overhead of accessing the table</strong> because threads have to acquire a latch for every slot they access. The DBMS can use a single mode latch (i.e., Spin Latch) to reduce meta-data and computational overhead.</li></ul></blockquote><p>即使上面有两种方式，它们锁粒度的不一样，造成其他地方很多也不一样。但是对并行控制的核心想法是一致的:</p><ul><li>所有的线程总是以<strong>从前往后</strong>固定的方向去获得数据 (获得下一个page / 获得下一个slot)</li><li>因此每一个线程可以保证线程安全:<ul><li>1.先松开当前 page / slot 的latch</li><li>2.再去获得下一个 page / slot 的latch</li></ul></li><li>上面两步之间可能会有其他的线程先拿走了下一个 page / slot, 但是这样的行为不影响我们的线程安全性。</li></ul><p>我们下面有足够篇幅的例子去解释上面这部分的描述。例子中默认每个page有两个slot，另外我们使用read-write latch。</p><h2 id="Page-Latches"><a href="#Page-Latches" class="headerlink" title="Page Latches"></a>Page Latches</h2><p><img data-src="/images/CMU1544564/Lec09/18.jpg" alt="18.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/19.jpg" alt="19.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/20.jpg" alt="20.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/21.jpg" alt="21.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/22.jpg" alt="22.jpg"></p><ul><li>上图中<code>T1</code>完成第一步: <strong>先松开当前 page1 的latch</strong></li></ul><p><img data-src="/images/CMU1544564/Lec09/23.jpg" alt="23.jpg"></p><ul><li>上图中<code>T1</code>完成第二步: <strong>再去获得 page2 的latch</strong></li><li>上图中<code>T2</code>获得page1的latch</li></ul><p><img data-src="/images/CMU1544564/Lec09/24.jpg" alt="24.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/25.jpg" alt="25.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/26.jpg" alt="26.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/27.jpg" alt="27.jpg"></p><p><br></p><h2 id="Slot-Latches"><a href="#Slot-Latches" class="headerlink" title="Slot Latches"></a>Slot Latches</h2><p><img data-src="/images/CMU1544564/Lec09/28.jpg" alt="28.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/29.jpg" alt="29.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/30.jpg" alt="30.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/31.jpg" alt="31.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/32.jpg" alt="32.jpg"></p><ul><li>上图中<code>T1</code>完成第一步: <strong>先松开当前 slot 的latch</strong></li></ul><p><img data-src="/images/CMU1544564/Lec09/33.jpg" alt="33.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/34.jpg" alt="34.jpg"></p><ul><li>上图中<code>T1</code>完成第二步: <strong>再去获得下一个 slot 的latch</strong></li></ul><p><img data-src="/images/CMU1544564/Lec09/35.jpg" alt="35.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/36.jpg" alt="36.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/37.jpg" alt="37.jpg"></p><p><br><br><br><br><br></p><hr><h1 id="B-Tree-Concurrency-Control"><a href="#B-Tree-Concurrency-Control" class="headerlink" title="B+ Tree Concurrency Control"></a>B+ Tree Concurrency Control</h1><p><img data-src="/images/CMU1544564/Lec09/38.jpg" alt="38.jpg"></p><ul><li>上图中最后一点中: 如果不线程安全，可能导致触碰到不再有效的内存区域invalid memory location, 产生segment fault段错误。</li></ul><h2 id="线程不安全-Example"><a href="#线程不安全-Example" class="headerlink" title="线程不安全 - Example"></a>线程不安全 - Example</h2><p>下面我们用一个线程不安全的反例，来说明在B+ Tree中线程安全的重要意义。</p><h3 id="T1-running"><a href="#T1-running" class="headerlink" title="T1 running"></a>T1 running</h3><p><img data-src="/images/CMU1544564/Lec09/40.jpg" alt="40.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/41.jpg" alt="41.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/42.jpg" alt="42.jpg"></p><ul><li>直到上图，<code>T1</code>从leaf node中删除了<code>44</code>，<code>T1</code>发现leaf node没有满足一半填满(less half full)的状态，需要继续rebalance (from sibling)。这时<code>T1: delete 44</code>尚未完成。但是thread scheudler选择暂停<code>T1</code>。</li></ul><h3 id="T1-stalled-T2-running"><a href="#T1-stalled-T2-running" class="headerlink" title="T1 stalled, T2 running"></a>T1 stalled, T2 running</h3><p><img data-src="/images/CMU1544564/Lec09/43.jpg" alt="43.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/44.jpg" alt="44.jpg"></p><ul><li>直到上图，<code>T2</code>找到了<code>Node D</code>，并从它中得知并获得了<code>41</code>对应leaf node的指针，即指向<code>Node H</code>的指针(图中的蓝色箭头)。这时<code>T2: find 41</code>尚未完成。但是thread scheudler选择暂停<code>T2</code>。</li></ul><h3 id="T1-running-T2-stalled"><a href="#T1-running-T2-stalled" class="headerlink" title="T1 running, T2 stalled"></a>T1 running, T2 stalled</h3><p><img data-src="/images/CMU1544564/Lec09/45.jpg" alt="45.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/46.jpg" alt="46.jpg"></p><ul><li>直到上图，<code>T1</code>继续rebalance, 将<code>41</code>从sibling <code>Node H</code>中换到<code>Node I</code>。这时<code>T1: delete 44</code>尚未完成，但是delete部分已经完成，只是还没有return回主函数。这时thread scheudler选择暂停<code>T1</code>。</li></ul><h3 id="T1-stalled-T2-running-1"><a href="#T1-stalled-T2-running-1" class="headerlink" title="T1 stalled, T2 running"></a>T1 stalled, T2 running</h3><p><img data-src="/images/CMU1544564/Lec09/47.jpg" alt="47.jpg"></p><ul><li>直到上图，<code>T2</code>使用之前获得的指向<code>Node H</code>的指针(图中的蓝色箭头)， 并成功到达<code>Node H</code>。只是<code>Node H</code>中没有<code>41</code>，这时<code>T2: find 41</code>完成，只是return false，说明B+ Tree中不存在<code>41</code>。</li><li>这明显是 <strong>False Positive</strong>, 因为树中真实存在<code>41</code>, <code>T2</code>判断错误。</li></ul><p><br><br><br><br><br></p><h2 id="Latch-Crabbing-Coupling-Protocol"><a href="#Latch-Crabbing-Coupling-Protocol" class="headerlink" title="Latch Crabbing / Coupling Protocol"></a>Latch Crabbing / Coupling Protocol</h2><blockquote><p>Lock crabbing / coupling is a protocol to allow multiple threads to access/modify B+Tree at the same time.</p></blockquote><p><img data-src="/images/CMU1544564/Lec09/48.jpg" alt="48.jpg"></p><p>要取保先取得child latch并确认它是safe, 才能松开parent latch。就是说存在一个时刻，一个线程会有多于一个latch的可能。</p><h3 id="Basic-Latch-Crabbing-Protocol"><a href="#Basic-Latch-Crabbing-Protocol" class="headerlink" title="Basic Latch Crabbing Protocol"></a>Basic Latch Crabbing Protocol</h3><p><img data-src="/images/CMU1544564/Lec09/49.jpg" alt="49.jpg"></p><h4 id="Example1-Find-38"><a href="#Example1-Find-38" class="headerlink" title="Example1 - Find 38"></a>Example1 - Find 38</h4><p><img data-src="/images/CMU1544564/Lec09/50.jpg" alt="50.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/51.jpg" alt="51.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/52.jpg" alt="52.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/53.jpg" alt="53.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/54.jpg" alt="54.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/55.jpg" alt="55.jpg"></p><h4 id="Example2-Delete-38"><a href="#Example2-Delete-38" class="headerlink" title="Example2 - Delete 38"></a>Example2 - Delete 38</h4><p><img data-src="/images/CMU1544564/Lec09/56.jpg" alt="56.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/57.jpg" alt="57.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/58.jpg" alt="58.jpg"></p><ul><li>在上图中，我们找到了<code>38</code>, 发现删除了它，<code>Inner Node D</code>依然是safe的。这之后我们决定松开<code>Node A</code>的latch，和松开<code>Node B</code>的latch。</li><li>松开<code>Node A</code>和<code>Node B</code>latch的先后并不影响正确性。但是<code>Node A</code>下覆盖的节点更多，潜在地有更多线程想要获得<code>Node A</code>的latch。因此先松开<code>Node A</code>的latch，再松开<code>Node B</code>的latch，性能更好。</li></ul><p><img data-src="/images/CMU1544564/Lec09/59.jpg" alt="59.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/60.jpg" alt="60.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/61.jpg" alt="61.jpg"></p><h4 id="Example3-Insert-45"><a href="#Example3-Insert-45" class="headerlink" title="Example3 - Insert 45"></a>Example3 - Insert 45</h4><p><img data-src="/images/CMU1544564/Lec09/62.jpg" alt="62.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/63.jpg" alt="63.jpg"></p><ul><li>在上图中，我们发现<code>Node B</code>是safe的。这之后我们决定松开<code>Node A</code>的latch。</li></ul><p><img data-src="/images/CMU1544564/Lec09/64.jpg" alt="64.jpg"></p><ul><li>在上图中，我们发现<code>Node D</code>是满的，对insertion不是safe的。我们决定保持<code>Node B</code>的latch。</li></ul><p><img data-src="/images/CMU1544564/Lec09/65.jpg" alt="65.jpg"></p><ul><li>在上图中，我们发现<code>Node I</code>是safe的。这之后我们决定松开<code>Node B</code>的latch，和松开<code>Node D</code>的latch。</li><li>松开<code>Node B</code>和<code>Node D</code>latch的先后并不影响正确性。但是<code>Node B</code>下覆盖的节点更多，潜在地有更多线程想要获得<code>Node D</code>的latch。因此先松开<code>Node B</code>的latch，再松开<code>Node D</code>的latch，性能更好。</li></ul><p><img data-src="/images/CMU1544564/Lec09/66.jpg" alt="66.jpg"></p><h4 id="Example4-Insert-25"><a href="#Example4-Insert-25" class="headerlink" title="Example4 - Insert 25"></a>Example4 - Insert 25</h4><p><img data-src="/images/CMU1544564/Lec09/67.jpg" alt="67.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/68.jpg" alt="68.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/69.jpg" alt="69.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/70.jpg" alt="70.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/71.jpg" alt="71.jpg"></p><ul><li>在上图中，我们发现<code>Node F</code>是满的，对insertion不是safe的。我们决定保持<code>Node C</code>的latch。</li></ul><p><img data-src="/images/CMU1544564/Lec09/72.jpg" alt="72.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/73.jpg" alt="73.jpg"></p><ul><li>在上图中，只有当前线程才能访问新建的节点，其他的线程甚至只能排队等去访问<code>Node C</code>。这种情况下，新建节点不需要上锁，可以节省开销。</li></ul><p><br></p><p>从上面所有的例子中， 我们可以发现，我们需要有一个<strong>FIFO list</strong>去记录一路上获得的latch。先获得的latch， 可以先松开， 因此是使用FIFO数据结构。</p><p><br><br><br></p><h3 id="Improved-Lock-Crabbing-Protocol"><a href="#Improved-Lock-Crabbing-Protocol" class="headerlink" title="Improved Lock Crabbing Protocol"></a>Improved Lock Crabbing Protocol</h3><h4 id="Observation"><a href="#Observation" class="headerlink" title="Observation"></a>Observation</h4><blockquote><p>The problem with the basic latch crabbing algorithm is that transactions always acquire an <strong>exclusive latch on the root for every insert/delete operation</strong>. <strong>This limits parallelism</strong>.</p><p>Instead, we can <strong>assume that having to resize (i.e., split/merge nodes) is rare, and thus transactions can acquire shared latches down to the leaf nodes</strong>. Each transaction will assume that the path to the target leaf node is safe, and <strong>use READ latches and crabbing to reach it, and verify. If any node in the path is not safe, then do previous algorithm (i.e., acquire WRITE latches).</strong></p></blockquote><p>我们发现对应写操作(Insert和Delete)一开始，必须获得root node的latch。那样的话，其他的想要进行读操作或者写操作的线程必须等待这个获得root node latch的线程松开这个latch。这个地方会造成很多线程的等待，是并行B+ Tree性能的一个瓶颈 bottleneck。</p><p><img data-src="/images/CMU1544564/Lec09/74.jpg" alt="74.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/75.jpg" alt="75.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/76.jpg" alt="76.jpg"></p><ul><li>Concurrency of operations on B-trees - R. Bayer &amp; M. Schkolnick: <span class="exturl" data-url="aHR0cHM6Ly9saW5rLnNwcmluZ2VyLmNvbS9hcnRpY2xlLzEwLjEwMDcvQkYwMDI2Mzc2Mg==" title="https://link.springer.com/article/10.1007/BF00263762">https://link.springer.com/article/10.1007/BF00263762<i class="fa fa-external-link"></i></span> </li></ul><p><img data-src="/images/CMU1544564/Lec09/84.jpg" alt="84.jpg"></p><ul><li>(上图中这页课件，被我从后面提前至此)</li></ul><blockquote><ul><li><strong>Search</strong>: Same algorithm as before.</li><li><strong>Insert/Delete</strong>: <strong>Set READ latches as if for search, go to leaf, and set WRITE latch on leaf. If leaf is not safe, release all previous latches, and restart transaction using previous Insert/Delete protocol.</strong></li></ul></blockquote><h4 id="Example2-Delete-38-New-Version"><a href="#Example2-Delete-38-New-Version" class="headerlink" title="Example2 - Delete 38 - New Version"></a>Example2 - Delete 38 - New Version</h4><p><img data-src="/images/CMU1544564/Lec09/77.jpg" alt="77.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/78.jpg" alt="78.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/79.jpg" alt="79.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/80.jpg" alt="80.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/81.jpg" alt="81.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/82.jpg" alt="82.jpg"></p><h4 id="Example4-Insert-25-New-Version"><a href="#Example4-Insert-25-New-Version" class="headerlink" title="Example4 - Insert 25 - New Version"></a>Example4 - Insert 25 - New Version</h4><p><img data-src="/images/CMU1544564/Lec09/83.jpg" alt="83.jpg"></p><ul><li>在上图中，我们发现<code>Node F</code>是满的，对insertion不是safe的。这个线程需要松开<code>Node F</code>的latch。重新开始，从Root Node开始，用write mode latch去进行<code>Insert 25</code>这个操作。</li></ul><p><br><br><br><br><br></p><h2 id="Leaf-Node-Scans"><a href="#Leaf-Node-Scans" class="headerlink" title="Leaf Node Scans"></a>Leaf Node Scans</h2><p><img data-src="/images/CMU1544564/Lec09/85.jpg" alt="85.jpg"></p><blockquote><p>The threads in these protocols acquire latches in a “top-down” manner. This means that a thread can only acquire a latch from a node that is below its current node. If the desired latch is unavailable, the thread must wait until it becomes available. <strong>Given this, there can never be deadlocks.</strong><br><strong>Leaf node scans are susceptible to deadlocks</strong> because now we have threads trying to acquire locks in two different directions at the same time (i.e., <strong>left-to-right and right-to-left</strong>). Index latches do not support deadlock detection or avoidance.<br>Thus, the only way we can deal with this problem is through coding discipline. <strong>The leaf node sibling latch acquisition protocol must support a “no-wait” mode</strong>. That is, B+tree code <strong>must cope with failed latch acquisitions</strong>. This means that <strong>if a thread tries to acquire a latch on a leaf node but that latch is unavailable, then it will immediately abort its operation (releasing any latches that it holds) and then restart the operation</strong>.</p></blockquote><p><img data-src="/images/CMU1544564/Lec09/102.jpg" alt="102.jpg"></p><ul><li>(上图中这页课件，被我从后面提前至此)</li></ul><h3 id="Leaf-Node-Scan-Example1"><a href="#Leaf-Node-Scan-Example1" class="headerlink" title="Leaf Node Scan Example1"></a>Leaf Node Scan Example1</h3><p>right-to-left leaf node scan. Read mode latch</p><p><img data-src="/images/CMU1544564/Lec09/86.jpg" alt="86.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/87.jpg" alt="87.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/88.jpg" alt="88.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/89.jpg" alt="89.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/90.jpg" alt="90.jpg"></p><h3 id="Leaf-Node-Scan-Example2"><a href="#Leaf-Node-Scan-Example2" class="headerlink" title="Leaf Node Scan Example2"></a>Leaf Node Scan Example2</h3><p>T1: right-to-left leaf node scan. Read mode latch<br>T2: left-to-right leaf node scan. Read mode latch</p><p><img data-src="/images/CMU1544564/Lec09/91.jpg" alt="91.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/92.jpg" alt="92.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/93.jpg" alt="93.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/94.jpg" alt="94.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/95.jpg" alt="95.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/96.jpg" alt="96.jpg"></p><h3 id="Leaf-Node-Scan-Example3"><a href="#Leaf-Node-Scan-Example3" class="headerlink" title="Leaf Node Scan Example3"></a>Leaf Node Scan Example3</h3><p>T1: top-to-bottom tree traversal scan. Write mode latch<br>T2: left-to-right leaf node scan. Read mode latch</p><p><img data-src="/images/CMU1544564/Lec09/97.jpg" alt="97.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/98.jpg" alt="98.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/99.jpg" alt="99.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/100.jpg" alt="100.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/101.jpg" alt="101.jpg"></p><p>DEAKLOCK!</p><ul><li>因为<code>T2</code>并不和<code>T1</code>进行线程通信，因此它们不知道对方在进行什么操作。<code>T2</code>有几种不同可能的作法:<ul><li><code>T2</code>立即放弃获得<code>Node C</code>的latch, 重新开始，重头开始。</li><li><code>T2</code>让<code>T1</code>放弃<code>Node C</code>的latch, <code>T2</code>获得<code>Node C</code>的latch。而<code>T1</code>重新开始，重头开始。</li><li><code>T2</code>等待<code>Node C</code>的latch。但是为了避免deadlock。等完timeout就放弃获得<code>Node C</code>的latch, 重新开始，重头开始。</li></ul></li></ul><p><br><br><br><br><br></p><h2 id="Delayed-Parent-Updates"><a href="#Delayed-Parent-Updates" class="headerlink" title="Delayed Parent Updates"></a>Delayed Parent Updates</h2><p><img data-src="/images/CMU1544564/Lec09/103.jpg" alt="103.jpg"></p><h3 id="Example4-Insert-25-New-New-Version"><a href="#Example4-Insert-25-New-New-Version" class="headerlink" title="Example4 - Insert 25 - New New Version"></a>Example4 - Insert 25 - New New Version</h3><h4 id="T1-Insert-25"><a href="#T1-Insert-25" class="headerlink" title="T1: Insert 25"></a>T1: Insert 25</h4><p><img data-src="/images/CMU1544564/Lec09/104.jpg" alt="104.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/105.jpg" alt="105.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/106.jpg" alt="106.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/107.jpg" alt="107.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/108.jpg" alt="108.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/109.jpg" alt="109.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/110.jpg" alt="110.jpg"></p><ul><li>上图中: <code>T1</code>推迟对<code>Node C</code>中写入<code>31</code>这个操作。<code>T1</code>将这件事情记录在一个global table中，推迟到下一次对<code>Node C</code>有Write latch的时候。</li></ul><h4 id="T2-Find-31"><a href="#T2-Find-31" class="headerlink" title="T2: Find 31"></a>T2: Find 31</h4><p><img data-src="/images/CMU1544564/Lec09/111.jpg" alt="111.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/112.jpg" alt="112.jpg"></p><h4 id="T3-Insert-33"><a href="#T3-Insert-33" class="headerlink" title="T3: Insert 33"></a>T3: Insert 33</h4><p><img data-src="/images/CMU1544564/Lec09/113.jpg" alt="113.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/114.jpg" alt="114.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/115.jpg" alt="115.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/116.jpg" alt="116.jpg"></p><ul><li>上图中: <code>T3</code>从global table中发现，在对<code>Node C</code>有Write latch的时候有一个操作被推迟过。<code>T3</code>完成这个事件: 向<code>Node C</code>中写入<code>31</code>. 这样我们捎带piggyback一个之前的插入操作到一个新的插入操作, 均摊了性能花销.</li></ul><p><img data-src="/images/CMU1544564/Lec09/117.jpg" alt="117.jpg"></p><p>另外一个发现是Parent Node的信息可以延迟更新, 即处在一个信息过期的状态, 这不影响在Leaf Node的查找.</p><ul><li>因此我们删除的时候也可以延迟更新: 先删除Leaf Node中的元素, 之后延迟再删除Parent Node的元素(如果有对应的话)</li></ul><p><br><br><br><br><br></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p><img data-src="/images/CMU1544564/Lec09/118.jpg" alt="118.jpg"></p><p><img data-src="/images/CMU1544564/Lec09/119.jpg" alt="119.jpg"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Index Concurrency Control - 索引并发控制&lt;/p&gt;
&lt;p&gt;Slide: &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTkvc2xpZGVzLzA5LWluZGV4Y29uY3VycmVuY3kucGRm&quot; title=&quot;https://15445.courses.cs.cmu.edu/fall2019/slides/09-indexconcurrency.pdf&quot;&gt;https://15445.courses.cs.cmu.edu/fall2019/slides/09-indexconcurrency.pdf&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;Note: &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTkvbm90ZXMvMDktaW5kZXhjb25jdXJyZW5jeS5wZGY=&quot; title=&quot;https://15445.courses.cs.cmu.edu/fall2019/notes/09-indexconcurrency.pdf&quot;&gt;https://15445.courses.cs.cmu.edu/fall2019/notes/09-indexconcurrency.pdf&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;Readings:  Chapter 15.10&lt;/p&gt;
&lt;p&gt;我们在之前的课程中已经学了一些数据库中的索引数据结构，主要有Hash Table和B+树。我们已经了解过它们中的操作，性能，使用范围。这次我们对它们做并发控制的研究 - 并发能给数据库带来很大的性能提升。绝大多数的数据库(以及数据库组件)都需要做到多线程，来提高性能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Access Methods" scheme="https://cakebytheoceanluo.github.io/categories/Access-Methods/"/>
    
      <category term="CMU-15445" scheme="https://cakebytheoceanluo.github.io/categories/CMU-15445/"/>
    
      <category term="B Tree" scheme="https://cakebytheoceanluo.github.io/categories/B-Tree/"/>
    
      <category term="Hash Table" scheme="https://cakebytheoceanluo.github.io/categories/Hash-Table/"/>
    
      <category term="Data Structure" scheme="https://cakebytheoceanluo.github.io/categories/Data-Structure/"/>
    
      <category term="Indexing" scheme="https://cakebytheoceanluo.github.io/categories/Indexing/"/>
    
      <category term="Operating System" scheme="https://cakebytheoceanluo.github.io/categories/Operating-System/"/>
    
      <category term="Lock" scheme="https://cakebytheoceanluo.github.io/categories/Lock/"/>
    
      <category term="Multithreading" scheme="https://cakebytheoceanluo.github.io/categories/Multithreading/"/>
    
    
      <category term="B Tree" scheme="https://cakebytheoceanluo.github.io/tags/B-Tree/"/>
    
      <category term="Indexing" scheme="https://cakebytheoceanluo.github.io/tags/Indexing/"/>
    
      <category term="Lock" scheme="https://cakebytheoceanluo.github.io/tags/Lock/"/>
    
      <category term="Latch" scheme="https://cakebytheoceanluo.github.io/tags/Latch/"/>
    
      <category term="Latch Coupling" scheme="https://cakebytheoceanluo.github.io/tags/Latch-Coupling/"/>
    
  </entry>
  
  <entry>
    <title>[CMU-15445]Lec08 - Fall18 - Skip List - 跳表</title>
    <link href="https://cakebytheoceanluo.github.io/2020/10/03/CMU-15445-Lec08-fall18/"/>
    <id>https://cakebytheoceanluo.github.io/2020/10/03/CMU-15445-Lec08-fall18/</id>
    <published>2020-10-03T11:00:40.000Z</published>
    <updated>2020-10-17T11:54:36.091Z</updated>
    
    <content type="html"><![CDATA[<p>Tree Indexes Part II - 树索引 II<br>Skip List - 跳表</p><p>Slide: <span class="exturl" data-url="aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTgvc2xpZGVzLzA4LXRyZWVzMi5wZGY=" title="https://15445.courses.cs.cmu.edu/fall2018/slides/08-trees2.pdf">https://15445.courses.cs.cmu.edu/fall2018/slides/08-trees2.pdf<i class="fa fa-external-link"></i></span><br>Note: <span class="exturl" data-url="aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTgvbm90ZXMvMDgtdHJlZXMyLnBkZg==" title="https://15445.courses.cs.cmu.edu/fall2018/notes/08-trees2.pdf">https://15445.courses.cs.cmu.edu/fall2018/notes/08-trees2.pdf<i class="fa fa-external-link"></i></span><br>Readings:  Chapter 11.1-11.4</p><p>这次只是对Lec08进行一个补充，因为Fall19没有讲Skip List, 但是之前Fall18提过它。它也是一个很重要的数据结构，一个很典型的概率型数据结构。</p><a id="more"></a><h1 id="Observation"><a href="#Observation" class="headerlink" title="Observation"></a>Observation</h1><p>我们知道Sorted Linked List中的查找需要$O(n)$的复杂度.</p><p>复杂度并不满足我们的要求, 是否能让这个线性搜索更快一些. 一个简单的想法是在每个节点多存储一些指针pointer, 让从每个节点可以跳得更远。</p><p><img data-src="/images/CMU1544564/Lec08/fall18_22.jpg" alt="fall18_22.jpg"></p><h1 id="Skip-List-跳表"><a href="#Skip-List-跳表" class="headerlink" title="Skip List 跳表"></a>Skip List 跳表</h1><blockquote><p>A skip list is a sorted linked list with multiple levels of extra points that skip over intermediate nodes. In general, a level has half the keys of the level below it. It provides approximately $O(\log(n))$ searches.</p></blockquote><p>Skip List是一个很有名而且典型的概率型数据结构 probabilistic data structure</p><p><img data-src="/images/CMU1544564/Lec08/fall18_23.jpg" alt="fall18_23.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/fall18_24.jpg" alt="fall18_24.jpg"></p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>我们想象Skip List有很多层，每一层可以看成是一个Sorted Linked List, 但是每层存储的元素不一定相同, 另外每层的搜索到元素的平均概率也不一样. </p><ul><li>最下面的一层, 存储了所有的元素, 因此在这一层100%能搜索到查找的元素, 这一层的Linked List也最长.</li><li>除了最下面的一层, 其他的层只存储指针, 而不存储元素本身的copy. 像下图中, 高层的节点有指向低层节点的指针, 在垂直方向形成了一个Tower. </li></ul><p><img data-src="/images/CMU1544564/Lec08/fall18_25.jpg" alt="fall18_25.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/fall18_26.jpg" alt="fall18_26.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/fall18_27.jpg" alt="fall18_27.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/fall18_28.jpg" alt="fall18_28.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/fall18_29.jpg" alt="fall18_29.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/fall18_30.jpg" alt="fall18_30.jpg"></p><h2 id="Insert-Key-5"><a href="#Insert-Key-5" class="headerlink" title="Insert Key 5"></a>Insert Key 5</h2><p>这里我们想插入元素5, 我们100%将5插入到最下面的一层. 但是随机选择其他的层, 去插入. 在下图的例子中, 概率事件是我们选择了中间层和最高层, 自然其他不同的概率事件也可以发生.</p><p><img data-src="/images/CMU1544564/Lec08/fall18_31.jpg" alt="fall18_31.jpg"></p><p>下图中, 我们先新建这三个节点, 并让它们指向对应层的对应元素, 注意这时候它们并未真正被插入到Skip List中, 因为我们从左侧开始是搜索不到这三个新元素的. 对于外界, 这三个新元素是<strong>不可见</strong>的:</p><p><img data-src="/images/CMU1544564/Lec08/fall18_32.jpg" alt="fall18_32.jpg"></p><p>接下来, 我们开始真正的插入. 先从最下面一层开始, 我们使用<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tcGFyZS1hbmQtc3dhcA==" title="https://en.wikipedia.org/wiki/Compare-and-swap">Compare and Swap<i class="fa fa-external-link"></i></span>去将Key 5插入到最下面那层. 然后再<strong>从下到上</strong>, 完成我们所有节点中对应层数的插入:</p><p><img data-src="/images/CMU1544564/Lec08/fall18_33.jpg" alt="fall18_33.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/fall18_34.jpg" alt="fall18_34.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/fall18_35.jpg" alt="fall18_35.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/fall18_36.jpg" alt="fall18_36.jpg"></p><h2 id="Find-Key-3"><a href="#Find-Key-3" class="headerlink" title="Find Key 3"></a>Find Key 3</h2><p>查找的顺序是从上到下, 最上层搜索成功的概率最小, 但是它的长度也最短, 查找最快. 我们在查找中利用特性: 每一层已经被排序:</p><p><img data-src="/images/CMU1544564/Lec08/fall18_37.jpg" alt="fall18_37.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/fall18_38.jpg" alt="fall18_38.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/fall18_39.jpg" alt="fall18_39.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/fall18_40.jpg" alt="fall18_40.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/fall18_41.jpg" alt="fall18_41.jpg"></p><h2 id="Delete-Key-5"><a href="#Delete-Key-5" class="headerlink" title="Delete Key 5"></a>Delete Key 5</h2><p>对于删除我们区分两种情况:</p><ul><li>logically 逻辑上删除: 仅仅将一个flag设置成false, 这样对应元素依然存在并可见, 只是即使我们查找到了它, 但是它在应用层面是一个无效的元素</li><li>physically 物理上删除: 将对应元素从列表中抹除, 并释放对应的内存区域. 这之后元素就消失了. 这里工作量更大一些, 因为我们要在每一层保证内存安全和线程安全</li></ul><p><img data-src="/images/CMU1544564/Lec08/fall18_42.jpg" alt="fall18_42.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/fall18_43.jpg" alt="fall18_43.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/fall18_44.jpg" alt="fall18_44.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/fall18_45.jpg" alt="fall18_45.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/fall18_46.jpg" alt="fall18_46.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/fall18_47.jpg" alt="fall18_47.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/fall18_48.jpg" alt="fall18_48.jpg"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img data-src="/images/CMU1544564/Lec08/fall18_49.jpg" alt="fall18_49.jpg"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tree Indexes Part II - 树索引 II&lt;br&gt;Skip List - 跳表&lt;/p&gt;
&lt;p&gt;Slide: &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTgvc2xpZGVzLzA4LXRyZWVzMi5wZGY=&quot; title=&quot;https://15445.courses.cs.cmu.edu/fall2018/slides/08-trees2.pdf&quot;&gt;https://15445.courses.cs.cmu.edu/fall2018/slides/08-trees2.pdf&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;Note: &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTgvbm90ZXMvMDgtdHJlZXMyLnBkZg==&quot; title=&quot;https://15445.courses.cs.cmu.edu/fall2018/notes/08-trees2.pdf&quot;&gt;https://15445.courses.cs.cmu.edu/fall2018/notes/08-trees2.pdf&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;Readings:  Chapter 11.1-11.4&lt;/p&gt;
&lt;p&gt;这次只是对Lec08进行一个补充，因为Fall19没有讲Skip List, 但是之前Fall18提过它。它也是一个很重要的数据结构，一个很典型的概率型数据结构。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Access Methods" scheme="https://cakebytheoceanluo.github.io/categories/Access-Methods/"/>
    
      <category term="CMU-15445" scheme="https://cakebytheoceanluo.github.io/categories/CMU-15445/"/>
    
      <category term="Data Structure" scheme="https://cakebytheoceanluo.github.io/categories/Data-Structure/"/>
    
      <category term="Indexing" scheme="https://cakebytheoceanluo.github.io/categories/Indexing/"/>
    
    
      <category term="Indexing" scheme="https://cakebytheoceanluo.github.io/tags/Indexing/"/>
    
      <category term="Skip List" scheme="https://cakebytheoceanluo.github.io/tags/Skip-List/"/>
    
  </entry>
  
  <entry>
    <title>B Tree 练习</title>
    <link href="https://cakebytheoceanluo.github.io/2020/10/01/B-Tree-Exercise/"/>
    <id>https://cakebytheoceanluo.github.io/2020/10/01/B-Tree-Exercise/</id>
    <published>2020-10-01T14:30:18.000Z</published>
    <updated>2020-10-01T14:32:48.466Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章对我见过的B Tree的练习题进行了收录。</p><a id="more"></a><h1 id="TUM数据库课程练习课"><a href="#TUM数据库课程练习课" class="headerlink" title="TUM数据库课程练习课"></a>TUM数据库课程练习课</h1><h2 id="B-Tree-例题一a-1"><a href="#B-Tree-例题一a-1" class="headerlink" title="B Tree 例题一a 1"></a>B Tree 例题一a <sup><a href="#fn1">1</a></sup></h2><p>向该B Tree中, 插入元素3:<br><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_1_1.png" alt="B Tree"></p><p><br></p><p>结果:<br><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_1_2.png" alt="Result"></p><p>详细步骤:<br><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_1_3.png" alt="Steps"></p><h2 id="B-Tree-例题一b-1"><a href="#B-Tree-例题一b-1" class="headerlink" title="B Tree 例题一b 1"></a>B Tree 例题一b <sup><a href="#fn1">1</a></sup></h2><p>向该B Tree中, 删除元素20:<br><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_1_1.png" alt="B Tree"></p><p><br></p><p>结果:<br><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_1_4.png" alt="Result"></p><p>详细步骤:<br><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_1_5.png" alt="Steps"></p><h2 id="B-Tree-例题二-2"><a href="#B-Tree-例题二-2" class="headerlink" title="B Tree 例题二 2"></a>B Tree 例题二 <sup><a href="#fn2">2</a></sup></h2><p>向 $k=2$ 空的B Tree中，插入1到20:</p><p><br></p><p><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_2_1.png" alt="1-4"></p><p><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_2_2.png" alt="5"></p><p><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_2_3.png" alt="6-7"></p><p><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_2_4.png" alt="8"></p><p><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_2_5.png" alt="9-10"></p><p><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_2_6.png" alt="11"></p><p><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_2_7.png" alt="12-16"></p><p><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_2_8.png" alt="17"></p><p><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_2_9.png" alt="18-20"></p><p>我们是按照排序好的数列插入到空的B Tree中.我们能发现这B Tree并没有被填满.仔细思考，实际上有些位置是永久被浪费掉的(比如1,2后面的位置，如果我们不删除).这种情况是B Tree的minimal loading, 缺点很明显：浪费空间.</p><h2 id="B-Tree-例题三a-3"><a href="#B-Tree-例题三a-3" class="headerlink" title="B+ Tree 例题三a 3"></a>B+ Tree 例题三a <sup><a href="#fn3">3</a></sup></h2><p>向 $k=3, k^*=2$ 空的B+ Tree中，插入1到25:</p><ul><li>$2k$: inner node</li><li>$2k^*$: leaf node</li></ul><p><br></p><p><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_3_2.png" alt="1-4"></p><p><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_3_3.png" alt="5"></p><p><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_3_4.png" alt="6-7"></p><p><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_3_5.png" alt="8"></p><p><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_3_6.png" alt="9-10"></p><p><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_3_7.png" alt="11"></p><p><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_3_8.png" alt="12-16"></p><p><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_3_9.png" alt="17"></p><p><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_3_10.png" alt="18-22"></p><p><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_3_11.png" alt="25"></p><p>排序好的数列插入到空的B+ Tree中.B+ Tree依然没有被填满.仔细思考，实际上有些位置是永久被浪费掉的(比如1,2,3后面的位置，如果我们不删除).这种情况是B+ Tree的minimal loading, 缺点很明显：浪费空间.</p><p>这个结论需要记住 适用于B Tree和B+ Tree</p><h2 id="B-Tree-例题三b-3"><a href="#B-Tree-例题三b-3" class="headerlink" title="B+ Tree 例题三b 3"></a>B+ Tree 例题三b <sup><a href="#fn3">3</a></sup></h2><p>具象化上图中最后一个Node(即22, 23, 24, 25存储的那个Node).假设Node Page中存储的是Key和TID:</p><ul><li>TID: 是Record ID的同义词,<a href="https://cakebytheoceanluo.github.io/2020/03/11/CMU-15445-Lec03/#Record-ids-%E2%80%94-Unique-identifier">Record ID</a></li><li>存储的是Key和TID :<a href="https://cakebytheoceanluo.github.io/2020/09/29/CMU-15445-Lec08/#Append-Record-Id">类似思路</a></li></ul><p><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_3_1.png" alt="The Last Node"></p><ul><li>$P$: prevous pointer 指向前一个页面</li><li>$N$: next pointer 指向下一个页面</li><li>$S_x, S_y, S_z$: 真正存储数据(\<key, value\="">中的value)的地方</key,></li></ul><h2 id="B-Tree-例题四-1"><a href="#B-Tree-例题四-1" class="headerlink" title="B Tree 例题四 1"></a>B Tree 例题四 <sup><a href="#fn1">1</a></sup></h2><p>向 $k=2$ 空的B Tree中，插入1到24.对这个插入数列进行排列组合,让B Tree拥有最小的高度:</p><ul><li><strong>高度</strong>: 是直接影响B Tree中操作<strong>性能</strong>的一个重要因素.每多一层(level),意味着Cahce Miss甚至Page Miss的次数会更多.</li><li><strong>最小的高度</strong>: 实际就是让每个node都尽可能被填满, maximal loading</li><li>$24 / (2 * k) = 24 / 4 = 6$: 我们的目的是需要6个被填满的B Tree节点</li></ul><p><br></p><p>下图是结果</p><p><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_4_1.png" alt="Result"></p><p>这是一种可能的排列组合(当然存在其他的可能)，去获得上图中的结果:  </p><p>1, 2, 5, 6, 7, 10, 11, 12, 15, 16, 17, 20, 21, 22, 3, 4, 8, 9, 13, 14, 18, 19, 23, 24.</p><p><br></p><p>我们在B Tree的插入中磨蹭了很久，希望大家对B Tree已经充分了解了.我们看到存储相同的数字(e.g. 1-24), 结果可能是不同形状的树， 甚至插入的性能也千差万别.</p><p>我在这里再提一下 常用的大量插入方式: <em>Bulkloading</em> or <em>Bulk Insert</em>: <a href="https://cakebytheoceanluo.github.io/2020/03/19/CMU-15445-Lec07/#Bulk-Insert">https://cakebytheoceanluo.github.io/2020/03/19/CMU-15445-Lec07/#Bulk-Insert</a></p><h2 id="B-Tree-例题四-4"><a href="#B-Tree-例题四-4" class="headerlink" title="B Tree 例题四 4"></a>B Tree 例题四 <sup><a href="#fn4">4</a></sup></h2><p>用B Tree存储十亿人(10,000,000,000)的信息:</p><ul><li>税号(Key): 64Bit (8Byte)，对每一个人都唯一，作为key</li><li>其他信息(Value): 名字，国家，城市，邮编，地址, 一共 100Byte</li></ul><p>每个页Page是16KiB大小. 假设Node Page中存储的是Key和Value. 假设CPU和OS都是64bit. <strong>求B Tree Node的k值</strong></p><p><br></p><p>, 即对应一个bucket。Bucket所在的page页的大小是4KiB。我们假设每一个bucket对应的page的75%的容量被使用。</p><ul><li>hash bucket中保存每一个对应的TID (8B), 这个TID对应一个页上的位置，存储着这个人的其他信息。</li><li>问: 存储这个hash table需要多少存储容量?</li></ul><p>答案:</p><ul><li><strong>CPU和OS都是64bit</strong>: 每个指针poitner的大小是 8Byte</li><li>B Tree <strong>Key是 8Byte, Value是 100Byte</strong></li></ul><p><img data-src="https://cakebytheoceanluo.github.io/images/GDB/BT_5_1.png" alt="Node"></p><ul><li>$V$: 指向页面的pointer指针</li><li>$S$: Key</li><li>$D$: Value</li></ul><p><br></p><script type="math/tex; mode=display">2*k*(\mathrm{Key} + \textrm{Value}) + (2*k+1) * \textrm{pointer} \leq 16 \textrm{KiB}</script><script type="math/tex; mode=display">2*k*(8B* + 100B) + (2*k+1) * 8B \leq 16 \textrm{KiB}</script><script type="math/tex; mode=display">2*k* 116B + 8B \leq 16376B</script><script type="math/tex; mode=display">k\leq 70.59</script><p>$k$可以是$70$</p><p><br></p><hr><p>引用:</p><ul><li><p><a name="fn1">1</a>: <span class="exturl" data-url="aHR0cHM6Ly9kYi5pbi50dW0uZGUvdGVhY2hpbmcvd3MxOTIwL2dydW5kbGFnZW4vTG9lc3VuZzEwLnBkZj9sYW5nPWRl" title="https://db.in.tum.de/teaching/ws1920/grundlagen/Loesung10.pdf?lang=de">https://db.in.tum.de/teaching/ws1920/grundlagen/Loesung10.pdf?lang=de<i class="fa fa-external-link"></i></span></p></li><li><p><a name="fn2">2</a>: <span class="exturl" data-url="aHR0cHM6Ly9kYi5pbi50dW0uZGUvdGVhY2hpbmcvd3MxNzE4L2dydW5kbGFnZW4vTG9lc3VuZzEwLnBkZj9sYW5nPWRl" title="https://db.in.tum.de/teaching/ws1718/grundlagen/Loesung10.pdf?lang=de">https://db.in.tum.de/teaching/ws1718/grundlagen/Loesung10.pdf?lang=de<i class="fa fa-external-link"></i></span></p></li><li><p><a name="fn3">3</a>: <span class="exturl" data-url="aHR0cHM6Ly9kYi5pbi50dW0uZGUvdGVhY2hpbmcvd3MxOTIwL2dydW5kbGFnZW4vTG9lc3VuZzA5LnBkZj9sYW5nPWRl" title="https://db.in.tum.de/teaching/ws1920/grundlagen/Loesung09.pdf?lang=de">https://db.in.tum.de/teaching/ws1920/grundlagen/Loesung09.pdf?lang=de<i class="fa fa-external-link"></i></span></p></li><li><p><a name="fn4">4</a>: <span class="exturl" data-url="aHR0cHM6Ly9kYi5pbi50dW0uZGUvdGVhY2hpbmcvd3MxNjE3L2dydW5kbGFnZW4vTG9lc3VuZzExLnBkZj9sYW5nPWRl" title="https://db.in.tum.de/teaching/ws1617/grundlagen/Loesung11.pdf?lang=de">https://db.in.tum.de/teaching/ws1617/grundlagen/Loesung11.pdf?lang=de<i class="fa fa-external-link"></i></span></p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章对我见过的B Tree的练习题进行了收录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Access Methods" scheme="https://cakebytheoceanluo.github.io/categories/Access-Methods/"/>
    
      <category term="B Tree" scheme="https://cakebytheoceanluo.github.io/categories/B-Tree/"/>
    
      <category term="Data Structure" scheme="https://cakebytheoceanluo.github.io/categories/Data-Structure/"/>
    
      <category term="Indexing" scheme="https://cakebytheoceanluo.github.io/categories/Indexing/"/>
    
    
      <category term="B Tree" scheme="https://cakebytheoceanluo.github.io/tags/B-Tree/"/>
    
      <category term="Indexing" scheme="https://cakebytheoceanluo.github.io/tags/Indexing/"/>
    
  </entry>
  
  <entry>
    <title>[CMU-15445]Lec08 Tree Indexes Part II - 树索引 II</title>
    <link href="https://cakebytheoceanluo.github.io/2020/09/29/CMU-15445-Lec08/"/>
    <id>https://cakebytheoceanluo.github.io/2020/09/29/CMU-15445-Lec08/</id>
    <published>2020-09-29T21:46:02.000Z</published>
    <updated>2020-10-02T07:40:08.702Z</updated>
    
    <content type="html"><![CDATA[<p>Tree Indexes Part II - 树索引 II</p><p>Slide: <span class="exturl" data-url="aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTkvc2xpZGVzLzA4LXRyZWVzMi5wZGY=" title="https://15445.courses.cs.cmu.edu/fall2019/slides/08-trees2.pdf">https://15445.courses.cs.cmu.edu/fall2019/slides/08-trees2.pdf<i class="fa fa-external-link"></i></span><br>Note: <span class="exturl" data-url="aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTkvbm90ZXMvMDgtdHJlZXMyLnBkZg==" title="https://15445.courses.cs.cmu.edu/fall2019/notes/08-trees2.pdf">https://15445.courses.cs.cmu.edu/fall2019/notes/08-trees2.pdf<i class="fa fa-external-link"></i></span><br>Readings:  Chapter 11.1-11.4</p><p>Database Tree Indexes 在CMU分成了两部分，在两节课中讲。这是第二部分。</p><p>这节课中，我们会学习数据库的中使用的除了B+树以外的树，这节课依然很数据结构。</p><p>因此，延续数据结构的思路，大家上完这节课可以思考一下，为什么我们没有见到我们学过的其他数据结构 - Binary Tree, AVL Tree, Red Black Tree? 它们适合数据库吗?</p><a id="more"></a><p><img data-src="/images/CMU1544564/Lec08/1.jpg" alt="1.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/3.jpg" alt="3.jpg"></p><p><br></p><h2 id="Duplicate-Keys"><a href="#Duplicate-Keys" class="headerlink" title="Duplicate Keys"></a>Duplicate Keys</h2><p><img data-src="/images/CMU1544564/Lec08/4.jpg" alt="4.jpg"></p><ul><li>处理Duplicate Keys有两种方法: Append Record Id, Overflow Leaf Nodes。我们下面会用例子去了解这两种作法。</li></ul><h3 id="Append-Record-Id"><a href="#Append-Record-Id" class="headerlink" title="Append Record Id"></a>Append Record Id</h3><p>我们之前提到过Record Id, 见<a href="https://cakebytheoceanluo.github.io/2020/03/11/CMU-15445-Lec03/#Record-ids-%E2%80%94-Unique-identifier">[CMU-15445] Lec03 Database Storage Part I - 数据库存储 I -Record ids - Unique identifier</a></p><p>Record Id又称RID，它代表对应元素存储的位置， 自然这个位置可以确定唯一的元素。</p><p><br></p><p>Append Record Id方法中: 我们即存储Key(可以重复), 也存储Record Id(不可能重复)。</p><p>比如下图中的<code>1</code>实际在page中的表示是<code>1 | record id of 1</code>:</p><p><img data-src="/images/CMU1544564/Lec08/5.jpg" alt="5.jpg"></p><h4 id="例子-Insert-6"><a href="#例子-Insert-6" class="headerlink" title="例子: Insert 6"></a>例子: Insert 6</h4><p>树中已经有了一个<code>6</code>, 我们假设它实际上是<code>6 | record id x</code>。另外我们还希望再插入另外一个<code>6</code>, 我们先将这个新的<code>6</code>存储在<code>record id y</code>，那么它在树中对应的表达应该是<code>6 | record id y</code>, 我们将这个对 插入树中:</p><p><img data-src="/images/CMU1544564/Lec08/6.jpg" alt="6.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/7.jpg" alt="7.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/8.jpg" alt="8.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/9.jpg" alt="9.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/10.jpg" alt="10.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/11.jpg" alt="11.jpg"></p><p><br></p><h3 id="Overflow-Leaf-Nodes"><a href="#Overflow-Leaf-Nodes" class="headerlink" title="Overflow Leaf Nodes"></a>Overflow Leaf Nodes</h3><p>Overflow Leaf Nodes使用另外一种方式，我们不再存储record id, 而是将重复的key存储在另外一个page上， 称为overflow page。这个page上我们选择不排序，同时还允许数值重复出现。我们每次插入在这个page的最后端。如果我们需要在overflow leaft nodes搜索数值，需要采取linear search, 原因是数值没有被排序。</p><p>具体见下列例子: </p><h4 id="Insert-6-7-6"><a href="#Insert-6-7-6" class="headerlink" title="Insert 6, 7, 6"></a>Insert 6, 7, 6</h4><p><img data-src="/images/CMU1544564/Lec08/12.jpg" alt="12.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/13.jpg" alt="13.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/14.jpg" alt="14.jpg"></p><p>overflow leaf nodes如果满了，依然还可以去增加新的overflow page给它。</p><hr><h1 id="SQL-Demo"><a href="#SQL-Demo" class="headerlink" title="SQL Demo"></a>SQL Demo</h1><p><img data-src="/images/CMU1544564/Lec08/15.jpg" alt="15.jpg"></p><p>更多关于这个 Demo 实验，见:</p><ul><li><a href="https://cakebytheoceanluo.github.io/2020/04/13/DBMS-Hash-Index%E4%B8%8ETree-Index/">[DBMS] Hash Index 与 Tree Index</a></li><li><a href="https://cakebytheoceanluo.github.io/2020/04/15/DBMS-Cluster-Index/">[DBMS] Cluster Index</a></li><li><a href="https://cakebytheoceanluo.github.io/2020/04/14/DBMS-Tree-Index-pageinspect/">[DBMS] Tree Index pageinspect 索引页面内容</a></li></ul><hr><h1 id="Additional-Index-Usage"><a href="#Additional-Index-Usage" class="headerlink" title="Additional Index Usage"></a>Additional Index Usage</h1><h2 id="Implicit-Indexes"><a href="#Implicit-Indexes" class="headerlink" title="Implicit Indexes"></a>Implicit Indexes</h2><blockquote><p>Implicit Indexes: Most DBMSs will automatically create an index to enforce integrity constraints (e.g., primary keys, unique constraints)</p></blockquote><h3 id="SERIAL-PRIMARY-KEY-UNIQUE"><a href="#SERIAL-PRIMARY-KEY-UNIQUE" class="headerlink" title="SERIAL PRIMARY KEY, UNIQUE"></a><code>SERIAL PRIMARY KEY</code>, <code>UNIQUE</code></h3><p><code>SERIAL PRIMARY KEY</code>, <code>UNIQUE</code>这些integrity constraint可以确定数值的<strong>唯一性</strong>。因此大多数数据库会给它们自动建立索引。</p><p><img data-src="/images/CMU1544564/Lec08/16.jpg" alt="16.jpg"></p><h3 id="REFERENCES-foreign-key"><a href="#REFERENCES-foreign-key" class="headerlink" title="REFERENCES - foreign key"></a><code>REFERENCES</code> - foreign key</h3><p>但是对<code>REFERENCES</code> - foreign key不会自动建立索引，因为foreign key对应的数值不一定是唯一的。比如下面的<code>foo.val1</code>是另外一个关系<code>bar</code>的外键foreign key, 但不会给它新建索引，原因是<code>foo.val1</code>可以是有重复值的。</p><p><img data-src="/images/CMU1544564/Lec08/18.jpg" alt="18.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/19.jpg" alt="19.jpg"></p><p><br></p><p><code>foo.val1</code>如果是<code>UNIQUE</code>的话，那对它建立索引也变得合理了。</p><p><img data-src="/images/CMU1544564/Lec08/20.jpg" alt="20.jpg"></p><h2 id="Partial-Indexes"><a href="#Partial-Indexes" class="headerlink" title="Partial Indexes"></a>Partial Indexes</h2><blockquote><p>Partial Indexes: Create an index on a subset of the entire table. This potentially reduces size and the amount of overhead to maintain it.</p></blockquote><p>Partial Indexes并不对整个关系中的所有tuple建立索引，只是对其中的一部分建立索引。下列例子中，只是对符合<code>foo.c = 'WuTang'</code>的tuple建立索引，因此也只能对这些tuple应用索引加速。</p><p><img data-src="/images/CMU1544564/Lec08/22.jpg" alt="22.jpg"></p><h2 id="Covering-Indexes"><a href="#Covering-Indexes" class="headerlink" title="Covering Indexes"></a>Covering Indexes</h2><blockquote><p>Covering Indexes: All attributes needed to process the query are available in an index, then the DBMS does not need to retrieve the tuple. The DBMS can complete the entire query just based on the data available in the index.</p></blockquote><p>Covering Indexes意味我们可以直接从index索引数据结构中获得数据，不需要跳到table存储的位置再读取信息。这样能带来更好的look up性能，但是也意味着index建立需要更长时间，index数据结构需要占据更多存储位置。因为数据被<strong>复制</strong>, 在table存储也被在index中存储，每一次数据变动都需要更新两个地方。</p><p><img data-src="/images/CMU1544564/Lec08/24.jpg" alt="24.jpg"></p><h2 id="Index-Include-Columns"><a href="#Index-Include-Columns" class="headerlink" title="Index Include Columns"></a>Index Include Columns</h2><p>Index Include Columns在Covering Indexes的基础上，再存储了另外的字段。这个<strong>另外的字段</strong>并不进入index索引判断，只是为了避免跳到table存储的位置再读取信息，提高性能。</p><p>这词很有趣，piggyback，<strong>另外的字段</strong>也就是被捎带的。它不会被存储在inner node, 因为不起到索引的作用。但是被存储在leaf node中。</p><p><img data-src="/images/CMU1544564/Lec08/25.jpg" alt="25.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/26.jpg" alt="26.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/28.jpg" alt="28.jpg"></p><h2 id="Functional-Expression-Indexes"><a href="#Functional-Expression-Indexes" class="headerlink" title="Functional / Expression Indexes"></a>Functional / Expression Indexes</h2><blockquote><p>Function/Expression Indexes: Store the output of a function or expression as the key instead of the original value. It is the DBMS’s job to recognize which queries can use that index.</p></blockquote><p><code>EXTRACT(dow FROM login) = 2</code>:</p><ul><li><code>dow</code> := day of week</li><li><code>EXTRACT(dow FROM login)</code> 从<code>login</code>这个时间点中获得<code>dow</code></li><li><code>EXTRACT(dow FROM login) = 2</code> 要求login时间点对应星期二</li></ul><p>对于<code>login</code>内部读取出的<code>dow</code>数据，针对<code>login</code>的索引不能帮助我们。</p><p><img data-src="/images/CMU1544564/Lec08/29.jpg" alt="29.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/30.jpg" alt="30.jpg"></p><p><br></p><p>Function/Expression Indexes在这种情况能帮助我们，它可以针对<code>login</code>中读取出的<code>dow</code>建立索引。</p><p>另外这种情况，我们上面见到的Pratial Index也可以帮助我们。具体情况，具体分析。</p><p><img data-src="/images/CMU1544564/Lec08/33.jpg" alt="33.jpg"></p><h1 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h1><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>数据集导入和使用见: <a href="https://cakebytheoceanluo.github.io/2020/03/15/DBMS-PostgreSQL%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE%E9%9B%86/#%E6%97%B6%E9%97%B4%E6%95%B0%E6%8D%AE%E9%9B%86">[DBMS] PostgreSQL 导入数据集 - 时间数据集</a></p><h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">testdb=# <span class="built_in">set</span> max_parallel_workers_per_gather = <span class="number">0</span>;</span><br><span class="line">SET</span><br><span class="line">testdb=# CREATE EXTENSION pg_prewarm;</span><br><span class="line">CREATE EXTENSION</span><br><span class="line">testdb=# SELECT pg_prewarm('users');</span><br><span class="line"> pg_prewarm </span><br><span class="line">------------</span><br><span class="line">      <span class="number">15023</span></span><br><span class="line">(<span class="number">1</span> row)</span><br><span class="line">testdb=# \timing</span><br><span class="line">Timing is on.</span><br></pre></td></tr></tbody></table></figure><h2 id="实验主体"><a href="#实验主体" class="headerlink" title="实验主体"></a>实验主体</h2><h3 id="无Index"><a href="#无Index" class="headerlink" title="无Index"></a>无Index</h3><p>无index的情况下，只能使用sequantial scan:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">testdb=# SELECT AVG(id) FROM users WHERE EXTRACT(dow FROM login) = <span class="number">2</span>;</span><br><span class="line">         avg          </span><br><span class="line">----------------------</span><br><span class="line"> <span class="number">1388880.500000000000</span></span><br><span class="line">(<span class="number">1</span> row)</span><br><span class="line"></span><br><span class="line">Time: <span class="number">607.678</span> ms</span><br><span class="line">testdb=# EXPLAIN SELECT AVG(id) FROM users WHERE EXTRACT(dow FROM login) = <span class="number">2</span>;</span><br><span class="line">                               QUERY PLAN                                </span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line"> Aggregate  (cost=<span class="number">56744.81</span>.<span class="number">.56744</span><span class="number">.82</span> rows=<span class="number">1</span> <span class="built_in">width</span>=<span class="number">32</span>)</span><br><span class="line">   -&gt;  <span class="function">Seq Scan on <span class="title">users</span>  <span class="params">(cost=<span class="number">0.00</span>.<span class="number">.56710</span><span class="number">.07</span> rows=<span class="number">13896</span> <span class="built_in">width</span>=<span class="number">4</span>)</span></span></span><br><span class="line">         Filter: (date_part('dow'::text, login) = '2'::double precision)</span><br><span class="line">(<span class="number">3</span> rows)</span><br><span class="line"></span><br><span class="line">Time: <span class="number">0.789</span> ms</span><br></pre></td></tr></tbody></table></figure><h3 id="有Index"><a href="#有Index" class="headerlink" title="有Index"></a>有Index</h3><p>我们使用了Function/Expression Index来优化查询，这样每次查询的时间缩短了很多。</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">testdb=# CREATE INDEX idx_user_login_partial ON users (login) WHERE EXTRACT(dow FROM login) = <span class="number">2</span>;</span><br><span class="line">CREATE INDEX</span><br><span class="line">testdb: <span class="number">805.588</span> ms</span><br><span class="line">time=# SELECT AVG(id) FROM users WHERE EXTRACT(dow FROM login) = <span class="number">2</span>;</span><br><span class="line">         avg          </span><br><span class="line">----------------------</span><br><span class="line"> <span class="number">1388880.500000000000</span></span><br><span class="line">(<span class="number">1</span> row)</span><br><span class="line"></span><br><span class="line">Time: <span class="number">67.753</span> ms</span><br><span class="line">testdb=# EXPLAIN SELECT AVG(id) FROM users WHERE EXTRACT(dow FROM login) = <span class="number">2</span>;</span><br><span class="line">                                           QUERY PLAN                                           </span><br><span class="line">------------------------------------------------------------------------------------------------</span><br><span class="line"> Aggregate  (cost=<span class="number">478.61</span>.<span class="number">.478</span><span class="number">.62</span> rows=<span class="number">1</span> <span class="built_in">width</span>=<span class="number">32</span>)</span><br><span class="line">   -&gt;  <span class="function">Index Scan <span class="keyword">using</span> idx_user_login_partial on <span class="title">users</span>  <span class="params">(cost=<span class="number">0.42</span>.<span class="number">.443</span><span class="number">.86</span> rows=<span class="number">13896</span> <span class="built_in">width</span>=<span class="number">4</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">(<span class="number">2</span> rows)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">Time: 0.464 ms</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="Observation-1"><a href="#Observation-1" class="headerlink" title="Observation 1"></a>Observation 1</h1><p>如果我们想在B+ Tree中搜索一个明知道不存在的key， 我们需要从root node经过inner node，到达leaf node，在遍历leaf node完以后，才能最终发现这个key不存在。</p><p><img data-src="/images/CMU1544564/Lec08/34.jpg" alt="34.jpg"></p><h1 id="Trie-Index"><a href="#Trie-Index" class="headerlink" title="Trie Index"></a>Trie Index</h1><p>Trie Index是另外一种树型tree-like的数据结构。它能解决我们上面的观察，它能搜索的途中发现一个key不存在于树中，不必从root到leaf。</p><p>Trie Index也称为: Digital Search Tree, Prefix Tree。 <strong>Radix Tree是Trie Tree的一种。</strong></p><p>Digital Representation: 可以是Bit, Byte, Char, Digit</p><p>Key不会以一个整体的形式直接出现，而是被解体分开decomponent至每一层。我们可以从路径(从root至leaf方向)中读出key。</p><p>下图中的最后的红色标志: 可以是对应的Record ID</p><p><img data-src="/images/CMU1544564/Lec08/36.jpg" alt="36.jpg"></p><h2 id="Trie-Index-Properties-vs-B-Tree-Properties"><a href="#Trie-Index-Properties-vs-B-Tree-Properties" class="headerlink" title="Trie Index Properties vs. B+ Tree Properties"></a>Trie Index Properties vs. B+ Tree Properties</h2><blockquote><p>A radix tree is a variant of a trie data structure. It uses digital representation of keys to examine prefixes one-by-one instead of comparing entire key. It is different than a trie in that there is not a node for each element in key, nodes are consolidated to represent the largest prefix before keys differ.</p><p>The height of tree depends on the length of keys and not the number of keys like in a + Tree. The path to a leaf nodes represents the key of the leaf. Not all attribute types can be decomposed into binary comparable digits for a radix tree.</p></blockquote><p><br></p><div class="table-container"><table><thead><tr><th>-</th><th>Trie Index</th><th>B+ Tree</th></tr></thead><tbody><tr><td><strong>树形状</strong></td><td>确定，不会根据insert的先后顺序变化。树形状的确定性由key的特征决定: 长度</td><td>不确定，会根据insert的先后顺序变化。有不同形状的树，但是它们包含的key是一样的。</td></tr><tr><td><strong>自平衡re-balance</strong></td><td>不需要</td><td>需要</td></tr><tr><td><strong>确定key是否存在</strong></td><td>不必须从root到leaf</td><td>必须从root到leaf</td></tr><tr><td><strong>key存储</strong></td><td>key不直接(implicitly stored)出现在树中。需要从root读到leaf, 才能间接地重建re-constructkey</td><td>key肯定直接存在于leaf node中，部分key另外还出现在root node和inner node中</td></tr><tr><td><strong>lookup, insert, delete - point query</strong></td><td>$O(k)$, k := length of the key， 大概率更快</td><td>$O(\log(n))$, n := number of keys， 大概率更慢</td></tr><tr><td><strong>sequential scan - range query</strong></td><td>leaf node间的sequential scan无意义。sequential scan相对繁琐，而且效率一般。每次遇到一个分岔，需要记录(track path), 遍历完一个分支以后，需要遍历分岔的其他分支。 — DFS深度搜索</td><td>可以进行leaf node间的sequential scan。非常简单且高效(sequential I/O)</td></tr></tbody></table></div><p><img data-src="/images/CMU1544564/Lec08/37.jpg" alt="37.jpg"></p><h2 id="Trie-Key-Span"><a href="#Trie-Key-Span" class="headerlink" title="Trie Key Span"></a>Trie Key Span</h2><p>Span:= 指的是key对应的进制编码</p><p>1-bit Span Trie:= 存储2进制的key，每一个node的分支数fan-out是2， 即0和1这两种可能。也叫2-way Trie。</p><p><img data-src="/images/CMU1544564/Lec08/38.jpg" alt="38.jpg"></p><h3 id="1-bit-Span-Trie例子"><a href="#1-bit-Span-Trie例子" class="headerlink" title="1-bit Span Trie例子"></a>1-bit Span Trie例子</h3><p>我们存储3个key: 10, 25, 31到下面的1-bit Span Trie中，具体key的二进制表达见下图:</p><p><img data-src="/images/CMU1544564/Lec08/40.jpg" alt="40.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/41.jpg" alt="41.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/42.jpg" alt="42.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/43.jpg" alt="43.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/44.jpg" alt="44.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/45.jpg" alt="45.jpg"></p><h3 id="优化1-horizontal-compreesion"><a href="#优化1-horizontal-compreesion" class="headerlink" title="优化1: horizontal compreesion"></a>优化1: horizontal compreesion</h3><p>因为是1-bit Span Trie，我们<strong>总是</strong>有两种选择: 0和1。我们可以不必存储0和1:</p><p><img data-src="/images/CMU1544564/Lec08/46.jpg" alt="46.jpg"></p><h3 id="优化2-vertical-compreesion"><a href="#优化2-vertical-compreesion" class="headerlink" title="优化2: vertical compreesion"></a>优化2: vertical compreesion</h3><p>另外如果当前路径已经确定 <strong>专属于一个key (single match)</strong> 的话，我们可以在最先可以确定唯一性的地方提前终止，提供指向tuple的record ID。这样能够减少存储量 - vertical compreesion。同时也可以提高性能。这样的树也被称为: <strong>Patricia Tree</strong>。</p><p>下图红圈的部分都是可以唯一确定key的，因此红圈部分被压缩，提前终止:</p><p><img data-src="/images/CMU1544564/Lec08/47.jpg" alt="47.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/48.jpg" alt="48.jpg"></p><p><br></p><h2 id="Insert-Delete"><a href="#Insert-Delete" class="headerlink" title="Insert, Delete"></a>Insert, Delete</h2><p>Radix Tree没特定的Modification算法。但是insert, delete都不困难。</p><p>Radix Tree允许多个字母一个节点，不同于Trie Tree。</p><h3 id="Insert-HAIR"><a href="#Insert-HAIR" class="headerlink" title="Insert HAIR"></a>Insert HAIR</h3><p><img data-src="/images/CMU1544564/Lec08/49.jpg" alt="49.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/50.jpg" alt="50.jpg"></p><h3 id="Delete-HAT"><a href="#Delete-HAT" class="headerlink" title="Delete HAT"></a>Delete HAT</h3><p><img data-src="/images/CMU1544564/Lec08/51.jpg" alt="51.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/52.jpg" alt="52.jpg"></p><h3 id="Delete-HAVE"><a href="#Delete-HAVE" class="headerlink" title="Delete HAVE"></a>Delete HAVE</h3><p><img data-src="/images/CMU1544564/Lec08/53.jpg" alt="53.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/54.jpg" alt="54.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/55.jpg" alt="55.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/56.jpg" alt="56.jpg"></p><p>最后一步中，我们尽可能的merge不必要的分岔，这样我们可以更早的去搜速到<code>HAIR</code></p><p><br></p><h2 id="Binary-Comparable-Keys"><a href="#Binary-Comparable-Keys" class="headerlink" title="Binary Comparable Keys"></a>Binary Comparable Keys</h2><p>(这部分Fall2019 上课没有讲, 我去看Fall2018。)</p><p>Trie Tree中如果使用Big Endian的表达，即从高位bit代表高位数字。那么我们需要从机器的Little Endian中倒转顺序。(X86的绝大部分CPU都是使用Little Endian)</p><p><img data-src="/images/CMU1544564/Lec08/57.jpg" alt="57.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/59.jpg" alt="59.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/60.jpg" alt="60.jpg"></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hex(168496141)</span><br><span class="line"><span class="string">'0xa0b0c0d'</span></span><br><span class="line">&gt;&gt;&gt; hex(658205)</span><br><span class="line"><span class="string">'0xa0b1d'</span></span><br></pre></td></tr></tbody></table></figure><p><br><br><br></p><h1 id="Observation-2"><a href="#Observation-2" class="headerlink" title="Observation 2"></a>Observation 2</h1><p>Tree Index只适合做point query和range query， 而不是适合做keyword search:</p><p><img data-src="/images/CMU1544564/Lec08/61.jpg" alt="61.jpg"></p><h2 id="Wikipedia-Example"><a href="#Wikipedia-Example" class="headerlink" title="Wikipedia Example"></a>Wikipedia Example</h2><p><img data-src="/images/CMU1544564/Lec08/62.jpg" alt="62.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/63.jpg" alt="63.jpg"></p><p>上面的SQL并不正确: 会搜索到<code>Pavlote</code>这样将<code>Pavlo</code>当做substring的词。</p><h1 id="Inverted-Index"><a href="#Inverted-Index" class="headerlink" title="Inverted Index"></a>Inverted Index</h1><p><img data-src="/images/CMU1544564/Lec08/64.jpg" alt="64.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/65.jpg" alt="65.jpg"></p><p><img data-src="/images/CMU1544564/Lec08/66.jpg" alt="66.jpg"></p><p>实际上这部分已经完全不再是课程的重点了，这些特殊的数据库甚至不再是关系数据库，关系表格的联系也在弱化。我提几个关键词和链接，大家可以自行了解:</p><ul><li>SPARQL</li><li>Linked Open Data Cloud</li><li>RDF datasets </li><li><span class="exturl" data-url="aHR0cHM6Ly9kYi5pbi50dW0uZGUvdGVhY2hpbmcvd3MxOTIwL2ZvdW5kYXRpb25zZGUvY2hhcHRlcjYucGRmP2xhbmc9ZGU=" title="https://db.in.tum.de/teaching/ws1920/foundationsde/chapter6.pdf?lang=de">TUM - Foundations in Data Engineering - Other Data Models<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYi5pbi50dW0uZGUvdGVhY2hpbmcvd3MxOTIwL2ZvdW5kYXRpb25zZGUvUkRGUXVlcnlPcHQucGRmP2xhbmc9ZGU=" title="https://db.in.tum.de/teaching/ws1920/foundationsde/RDFQueryOpt.pdf?lang=de">TUM - Foundations in Data Engineering - RDF Query Optimization<i class="fa fa-external-link"></i></span></li></ul><p>另外推荐论文: <span class="exturl" data-url="aHR0cHM6Ly9kYi5pbi50dW0uZGUvfmxlaXMvcGFwZXJzL0FSVC5wZGY=" title="https://db.in.tum.de/~leis/papers/ART.pdf">The Adaptive Radix Tree: ARTful Indexing for Main-Memory Databases<i class="fa fa-external-link"></i></span></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p><img data-src="/images/CMU1544564/Lec08/67.jpg" alt="67.jpg"></p><ul><li>CMU 11-442 Search Engines: <span class="exturl" data-url="aHR0cHM6Ly9ib3N0b24ubHRpLmNzLmNtdS5lZHUvY2xhc3Nlcy8xMS02NDIv" title="https://boston.lti.cs.cmu.edu/classes/11-642/">https://boston.lti.cs.cmu.edu/classes/11-642/<i class="fa fa-external-link"></i></span></li><li>CMU 15-826 Multimedia Databases and Data Mining: <span class="exturl" data-url="aHR0cHM6Ly93d3cuY3MuY211LmVkdS9+Y2hyaXN0b3MvY291cnNlcy84MjYuUzE3Lw==" title="https://www.cs.cmu.edu/~christos/courses/826.S17/">https://www.cs.cmu.edu/~christos/courses/826.S17/<i class="fa fa-external-link"></i></span></li></ul><p><img data-src="/images/CMU1544564/Lec08/68.jpg" alt="68.jpg"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tree Indexes Part II - 树索引 II&lt;/p&gt;
&lt;p&gt;Slide: &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTkvc2xpZGVzLzA4LXRyZWVzMi5wZGY=&quot; title=&quot;https://15445.courses.cs.cmu.edu/fall2019/slides/08-trees2.pdf&quot;&gt;https://15445.courses.cs.cmu.edu/fall2019/slides/08-trees2.pdf&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;Note: &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTkvbm90ZXMvMDgtdHJlZXMyLnBkZg==&quot; title=&quot;https://15445.courses.cs.cmu.edu/fall2019/notes/08-trees2.pdf&quot;&gt;https://15445.courses.cs.cmu.edu/fall2019/notes/08-trees2.pdf&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;Readings:  Chapter 11.1-11.4&lt;/p&gt;
&lt;p&gt;Database Tree Indexes 在CMU分成了两部分，在两节课中讲。这是第二部分。&lt;/p&gt;
&lt;p&gt;这节课中，我们会学习数据库的中使用的除了B+树以外的树，这节课依然很数据结构。&lt;/p&gt;
&lt;p&gt;因此，延续数据结构的思路，大家上完这节课可以思考一下，为什么我们没有见到我们学过的其他数据结构 - Binary Tree, AVL Tree, Red Black Tree? 它们适合数据库吗?&lt;/p&gt;
    
    </summary>
    
    
      <category term="Access Methods" scheme="https://cakebytheoceanluo.github.io/categories/Access-Methods/"/>
    
      <category term="CMU-15445" scheme="https://cakebytheoceanluo.github.io/categories/CMU-15445/"/>
    
      <category term="B Tree" scheme="https://cakebytheoceanluo.github.io/categories/B-Tree/"/>
    
      <category term="Data Structure" scheme="https://cakebytheoceanluo.github.io/categories/Data-Structure/"/>
    
      <category term="Indexing" scheme="https://cakebytheoceanluo.github.io/categories/Indexing/"/>
    
      <category term="Trie / Radix Tree" scheme="https://cakebytheoceanluo.github.io/categories/Trie-Radix-Tree/"/>
    
    
      <category term="B Tree" scheme="https://cakebytheoceanluo.github.io/tags/B-Tree/"/>
    
      <category term="Indexing" scheme="https://cakebytheoceanluo.github.io/tags/Indexing/"/>
    
      <category term="Trie / Radix Tree" scheme="https://cakebytheoceanluo.github.io/tags/Trie-Radix-Tree/"/>
    
      <category term="Additional Index Usage" scheme="https://cakebytheoceanluo.github.io/tags/Additional-Index-Usage/"/>
    
  </entry>
  
  <entry>
    <title>[CMU-15445]19_Projet1_disk_manager</title>
    <link href="https://cakebytheoceanluo.github.io/2020/08/17/CMU-15445-19-Projet1-disk-manager/"/>
    <id>https://cakebytheoceanluo.github.io/2020/08/17/CMU-15445-19-Projet1-disk-manager/</id>
    <published>2020-08-17T13:20:11.000Z</published>
    <updated>2020-08-17T19:27:25.006Z</updated>
    
    <content type="html"><![CDATA[<p>Disk Manager是数据库中对磁盘文件操作的抽象。它提供给Buffer Manager的粒度是一个page, 即它操作的最小单元是一个page。而操作可以分为allocation分配和deallocation释放。</p><p>在CMU Bustub中Disk Manager总是针对一个文件，每次从它上面获得或者写入page大小的数据量。Bustub是模拟SQLite, 而SQLite作为一个简单的数据库，只操作一个文件。当然其他复杂的数据集需要操作多个文件，那对应的Disk Manager需要去对应多个文件(open, read, write, close等操作)。我们下次有机会去考虑一下这样多文件的Disk Manger如何实现。而这次我们先打好基础，去理解CMU Bustub中单文件的Disk Manager。</p><p>另外这篇文章中不关注Log。它需要之后单独描述。我们会区分Log(也对应一个文件)和File，File指那个特定的我们想读取和写入的文件。</p><p>(另外CMU Bustub中的Disk Manager和CMU 17Fall 18Fall对应项目的Disk Manager没有区别)</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这部分我借用代码中的注释文档来对Disk Manager进行介绍:</p><ul><li>DiskManager takes care of the <strong>allocation and deallocation of pages</strong> within a database. It performs <strong>the reading and writing of pages to and from disk</strong>, providing a logical file layer within the context of a database management system.</li></ul><p><img data-src="https://cakebytheoceanluo.github.io/images/ModernDBS/Chap2/7.jpg" alt="7.jpg 引用见文章最后"></p><ul><li>Disk Manager隶属于上图File Interface: read block k, write block k</li><li>它可以对一个文件或者block进行读与写操作</li><li>它提供给Buffer Manager接口，让Buffer Manager可以以page粒度，对磁盘文件进行操作 (这就是Project1需要的部分)</li></ul><p><br></p><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p><img data-src="https://cakebytheoceanluo.github.io/images/CMU1544564/Project19/P1_1.png" alt="引入"></p><ul><li>上图中我们在硬盘上有一个File <code>"test.db"</code>, 他的大小是15000bit</li><li>bustub中Page的大小是4KiB: <code>src/include/common/config.h</code>中:<ul><li><code>static constexpr int PAGE_SIZE = 4096;                                        // size of a data page in byte</code></li></ul></li><li>因此这个文件不是整数倍的page大小， 我们<strong>向上取整</strong>，需要4个page去读取这个文件。</li><li>4个page对应的page_id即图中的0, 1, 2, 3。</li><li>我们可以从这个例子中理解，page_id和File中的byte位置是对应。</li></ul><h1 id="bustub-DiskManager"><a href="#bustub-DiskManager" class="headerlink" title="bustub::DiskManager"></a><code>bustub::DiskManager</code></h1><p>我们接下来来看代码: </p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NtdS1kYi9idXN0dWIvYmxvYi9tYXN0ZXIvc3JjL2luY2x1ZGUvc3RvcmFnZS9kaXNrL2Rpc2tfbWFuYWdlci5o" title="https://github.com/cmu-db/bustub/blob/master/src/include/storage/disk/disk_manager.h">https://github.com/cmu-db/bustub/blob/master/src/include/storage/disk/disk_manager.h<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NtdS1kYi9idXN0dWIvYmxvYi9tYXN0ZXIvc3JjL3N0b3JhZ2UvZGlzay9kaXNrX21hbmFnZXIuY3Bw" title="https://github.com/cmu-db/bustub/blob/master/src/storage/disk/disk_manager.cpp">https://github.com/cmu-db/bustub/blob/master/src/storage/disk/disk_manager.cpp<i class="fa fa-external-link"></i></span></li></ul><h3 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h3><p>attributes均为private.</p><p>Log所需成员:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stream to write log file</span></span><br><span class="line"><span class="built_in">std</span>::fstream log_io_;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> log_name_;</span><br><span class="line"><span class="keyword">bool</span> flush_log_;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">void</span>&gt; *flush_log_f_;</span><br><span class="line"><span class="keyword">int</span> num_flushes_;</span><br></pre></td></tr></tbody></table></figure><p>另外有一个class以外的全局变量:<br></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *buffer_used;</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>它是LOG的缓存区</li></ul><p><br></p><p>File所需成员:<br></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stream to write db file</span></span><br><span class="line"><span class="built_in">std</span>::fstream db_io_;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> file_name_;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">page_id_t</span>&gt; next_page_id_;</span><br><span class="line"><span class="keyword">int</span> num_writes_;</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li><code>std::fstream db_io_;</code>对应我们的File, 属于核心数据结构，提供文件操作,使用C++文件file stream接口。</li><li><code>std::string file_name_;</code>即文件名，用处是提供给<code>GetFileSize</code>方法</li><li><code>std::atomic&lt;page_id_t&gt; next_page_id_;</code>这个成员是<strong>线程安全的</strong>， 我们会在<code>AllocatePage</code>方法中用它</li><li><code>int num_writes_</code>记录<code>WritePage</code>调用的次数</li></ul><p><br></p><h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><h4 id="private-method"><a href="#private-method" class="headerlink" title="private method"></a>private method</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFileSize</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;file_name)</span> </span>{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></span><br><span class="line">  <span class="keyword">int</span> rc = stat(file_name.c_str(), &amp;stat_buf);</span><br><span class="line">  <span class="keyword">return</span> rc == <span class="number">0</span> ? <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(stat_buf.st_size) : <span class="number">-1</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>GetFileSize</code>: 获得<code>file_name</code>文件的大小， 使用<code>stat</code>这个syscall, 见<span class="exturl" data-url="aHR0cDovL21hbjcub3JnL2xpbnV4L21hbi1wYWdlcy9tYW4yL3N0YXQuMi5odG1s" title="http://man7.org/linux/man-pages/man2/stat.2.html">man stat<i class="fa fa-external-link"></i></span></li><li><blockquote><pre><code>   int stat(const char *pathname, struct stat *statbuf);</code></pre></blockquote></li><li><blockquote><p>On success, <strong>zero</strong> is returned.  On error, -1 is returned, and <em>errno</em> is set appropriately.</p></blockquote></li><li><blockquote><pre><code>           off_t     st_size;        /* Total size, in bytes */</code></pre></blockquote></li></ul><p><br></p><h4 id="public-methods"><a href="#public-methods" class="headerlink" title="public methods"></a>public methods</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new disk manager that writes to the specified database file.</span></span><br><span class="line"><span class="comment"> * @param db_file the file name of the database file to write to</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">explicit DiskManager(const std::string &amp;db_file) : file_name_(db_file), next_page_id_(0), num_flushes_(0), num_writes_(0), flush_log_(false), flush_log_f_(nullptr) {</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::size_type n = file_name_.<span class="built_in">find</span>(<span class="string">'.'</span>);</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="built_in">std</span>::<span class="built_in">string</span>::npos) {</span><br><span class="line">    LOG_DEBUG(<span class="string">"wrong file format"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** ---------- LOG相关部分 隐去 ----------*/</span></span><br><span class="line"></span><br><span class="line">  db_io_.<span class="built_in">open</span>(db_file, <span class="built_in">std</span>::ios::binary | <span class="built_in">std</span>::ios::in | <span class="built_in">std</span>::ios::out);</span><br><span class="line">  <span class="comment">// directory or file does not exist</span></span><br><span class="line">  <span class="keyword">if</span> (!db_io_.is_open()) {</span><br><span class="line">    db_io_.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="comment">// create a new file</span></span><br><span class="line">    db_io_.<span class="built_in">open</span>(db_file, <span class="built_in">std</span>::ios::binary | <span class="built_in">std</span>::ios::trunc | <span class="built_in">std</span>::ios::out);</span><br><span class="line">    db_io_.<span class="built_in">close</span>();</span><br><span class="line">    <span class="comment">// reopen with original mode</span></span><br><span class="line">    db_io_.<span class="built_in">open</span>(db_file, <span class="built_in">std</span>::ios::binary | <span class="built_in">std</span>::ios::in | <span class="built_in">std</span>::ios::out);</span><br><span class="line">  }</span><br><span class="line">  buffer_used = <span class="literal">nullptr</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>一开始对文件名格式进行检查, 它必须带<code>.</code>, 比如<code>"test.db"</code>: <code>std::string::size_type n = file_name_.find('.');</code></li><li>然后进行LOG文件的操作。我们在这篇文章中隐去。</li><li>最重要的是打开我们的File, 使用C++文件file stream接口。<ul><li>打开一个已存在的文件: <code>db_io_.open(db_file, std::ios::binary | std::ios::in | std::ios::out);</code></li><li>新建一个文件: <code>db_io_.open(db_file, std::ios::binary | std::ios::trunc | std::ios::out);</code></li><li>另外新建一个文件有多种作法, 见: <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE4MTYwODM3LzEwOTcxNjUw" title="https://stackoverflow.com/a/18160837/10971650">https://stackoverflow.com/a/18160837/10971650<i class="fa fa-external-link"></i></span></li><li><code>std::fstream::open</code>: <span class="exturl" data-url="aHR0cHM6Ly93d3cuY3BsdXNwbHVzLmNvbS9yZWZlcmVuY2UvZnN0cmVhbS9mc3RyZWFtL29wZW4v" title="https://www.cplusplus.com/reference/fstream/fstream/open/">https://www.cplusplus.com/reference/fstream/fstream/open/<i class="fa fa-external-link"></i></span></li></ul></li></ul><p><br><br><br></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~DiskManager() = <span class="keyword">default</span>;</span><br></pre></td></tr></tbody></table></figure><p><br><br><br></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Shut down the disk manager and close all the file resources. Close all file streams. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShutDown</span><span class="params">()</span> </span>{  db_io_.<span class="built_in">close</span>(); log_io_.<span class="built_in">close</span>(); }</span><br></pre></td></tr></tbody></table></figure><ul><li><code>close</code>这两个打开的文件</li></ul><p><br><br><br></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Write a page to the database file. Write the contents of the specified page into disk file</span></span><br><span class="line"><span class="comment"> * @param page_id id of the page</span></span><br><span class="line"><span class="comment"> * @param page_data raw page data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WritePage</span><span class="params">(<span class="keyword">page_id_t</span> page_id, <span class="keyword">const</span> <span class="keyword">char</span> *page_data)</span> </span>{</span><br><span class="line">  <span class="keyword">size_t</span> offset = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(page_id) * PAGE_SIZE;</span><br><span class="line">  <span class="comment">// set write cursor to offset</span></span><br><span class="line">  num_writes_ += <span class="number">1</span>;</span><br><span class="line">  db_io_.seekp(offset);</span><br><span class="line">  db_io_.<span class="built_in">write</span>(page_data, PAGE_SIZE);</span><br><span class="line">  <span class="comment">// check for I/O error</span></span><br><span class="line">  <span class="keyword">if</span> (db_io_.bad()) {</span><br><span class="line">    LOG_DEBUG(<span class="string">"I/O error while writing"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// needs to flush to keep disk file in sync</span></span><br><span class="line">  db_io_.<span class="built_in">flush</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><a href="#引入">引入</a>中我们用例子解释了: <code>size_t offset = static_cast&lt;size_t&gt;(page_id) * PAGE_SIZE;</code></li><li>这次写入增加<code>num_writes_</code></li><li>寻找文件的<code>offset</code>位置(开始写的起始位置)，进行一次<code>PAGE_SIZE</code>的写操作: <code>db_io_.seekp(offset); db_io_.write(page_data, PAGE_SIZE);</code></li><li>将操作系统缓存区的文件映射 写入至硬盘。同步持久化: <code>db_io_.flush();</code></li></ul><p><br><br><br></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Read a page from the database file.</span></span><br><span class="line"><span class="comment"> * @param page_id id of the page</span></span><br><span class="line"><span class="comment"> * @param[out] page_data output buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadPage</span><span class="params">(<span class="keyword">page_id_t</span> page_id, <span class="keyword">char</span> *page_data)</span> </span>{</span><br><span class="line">  <span class="keyword">int</span> offset = page_id * PAGE_SIZE;</span><br><span class="line">  <span class="comment">// check if read beyond file length</span></span><br><span class="line">  <span class="keyword">if</span> (offset &gt; GetFileSize(file_name_)) {</span><br><span class="line">    LOG_DEBUG(<span class="string">"I/O error while reading"</span>);</span><br><span class="line">    <span class="comment">// std::cerr &lt;&lt; "I/O error while reading" &lt;&lt; std::endl;</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// set read cursor to offset</span></span><br><span class="line">    db_io_.seekp(offset);</span><br><span class="line">    db_io_.<span class="built_in">read</span>(page_data, PAGE_SIZE);</span><br><span class="line">    <span class="comment">// if file ends before reading PAGE_SIZE</span></span><br><span class="line">    <span class="keyword">int</span> read_count = db_io_.gcount();</span><br><span class="line">    <span class="keyword">if</span> (read_count &lt; PAGE_SIZE) {</span><br><span class="line">      LOG_DEBUG(<span class="string">"Read less than a page"</span>);</span><br><span class="line">      <span class="comment">// std::cerr &lt;&lt; "Read less than a page" &lt;&lt; std::endl;</span></span><br><span class="line">      <span class="built_in">memset</span>(page_data + read_count, <span class="number">0</span>, PAGE_SIZE - read_count);</span><br><span class="line">    }</span><br><span class="line">  }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>ReadPage</code>和<code>WritePage</code>非常类似</li><li>需要确保<code>offset</code>读取的起始位置在文件之内: <code>if (offset &gt; GetFileSize(file_name_)) LOG_DEBUG("I/O error while reading");</code></li><li>寻找文件的<code>offset</code>位置(开始读的起始位置)，进行一次<code>PAGE_SIZE</code>的读操作: <code>db_io_.seekp(offset); db_io_.read(page_data, PAGE_SIZE);</code></li><li>参考<a href="#引入">引入</a>, 如果文件不是<code>PAGE_SIZE</code>的整数倍，将多读的部分(事实上不属于文件的部分)set成0: <code>int read_count = db_io_.gcount(); if (read_count &lt; PAGE_SIZE) { LOG_DEBUG("Read less than a page"); memset(page_data + read_count, 0, PAGE_SIZE - read_count); }</code></li><li><code>gcount()</code>方法， 见: <span class="exturl" data-url="aHR0cHM6Ly93d3cuY3BsdXNwbHVzLmNvbS9yZWZlcmVuY2UvaXN0cmVhbS9pc3RyZWFtL2djb3VudC8=" title="https://www.cplusplus.com/reference/istream/istream/gcount/">https://www.cplusplus.com/reference/istream/istream/gcount/<i class="fa fa-external-link"></i></span></li></ul><p><br><br><br></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Allocate new page (operations like create index/table)</span></span><br><span class="line"><span class="comment">  * For now just keep an increasing counter</span></span><br><span class="line"><span class="comment">  * @return the id of the allocated page</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">page_id_t</span> <span class="title">AllocatePage</span><span class="params">()</span> </span>{ <span class="keyword">return</span> next_page_id_++; }</span><br></pre></td></tr></tbody></table></figure><ul><li><code>std::atomic&lt;page_id_t&gt; next_page_id_;</code>这个成员是<strong>线程安全的</strong></li><li>因此这个<code>AllocatePage</code>方法也是<strong>线程安全</strong>的，我们调用这个方法的时候不需要加锁</li><li>另外这个方法没有被完全实现，见本文对应时间的项目: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NtdS1kYi9idXN0dWIvdHJlZS9mMzY2OWMzZTZkZmI1NjE3YjcyZGYxNmNhODRmODBmZTg3ZGYyMGRhI3RvZG8=" title="https://github.com/cmu-db/bustub/tree/f3669c3e6dfb5617b72df16ca84f80fe87df20da#todo">https://github.com/cmu-db/bustub/tree/f3669c3e6dfb5617b72df16ca84f80fe87df20da#todo<i class="fa fa-external-link"></i></span></li></ul><p><br><br><br></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Deallocate page (operations like drop index/table)</span></span><br><span class="line"><span class="comment"> * Need bitmap in header page for tracking pages</span></span><br><span class="line"><span class="comment"> * This does not actually need to do anything for now.</span></span><br><span class="line"><span class="comment"> * @param page_id id of the page to deallocate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeallocatePage</span><span class="params">(__attribute__((unused)) <span class="keyword">page_id_t</span> page_id)</span> </span>{}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>(__attribute__((unused))</code>只是去除编译器的Warning, 即使我们不使用方法参数<code>page_id</code>， 见: <span class="exturl" data-url="aHR0cHM6Ly9nY2MuZ251Lm9yZy9vbmxpbmVkb2NzL2djYy0zLjIvZ2NjL0Z1bmN0aW9uLUF0dHJpYnV0ZXMuaHRtbA==" title="https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Function-Attributes.html">https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Function-Attributes.html<i class="fa fa-external-link"></i></span></li><li><blockquote><p>This attribute, attached to a function, means that the function is meant to be possibly unused. GCC will not produce a warning for this function. GNU C++ does not currently support this attribute as definitions without parameters are valid in C++.</p></blockquote></li><li>另外这个方法没有被实现，见本文对应时间的项目: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NtdS1kYi9idXN0dWIvdHJlZS9mMzY2OWMzZTZkZmI1NjE3YjcyZGYxNmNhODRmODBmZTg3ZGYyMGRhI3RvZG8=" title="https://github.com/cmu-db/bustub/tree/f3669c3e6dfb5617b72df16ca84f80fe87df20da#todo">https://github.com/cmu-db/bustub/tree/f3669c3e6dfb5617b72df16ca84f80fe87df20da#todo<i class="fa fa-external-link"></i></span></li><li>(因为没有被实现)这个<code>DeallocatePage</code>方法也是<strong>线程安全</strong>的，我们调用这个方法的时候不需要加锁</li></ul><p><br><br><br></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @return the number of disk writes */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNumWrites</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> num_writes_; };</span><br></pre></td></tr></tbody></table></figure><ul><li><code>GetNumWrites</code>只是简单的Getter方法</li><li><code>num_writes_</code>在每次<code>WritePage</code>会增加一</li></ul><p><br><br><br></p><h5 id="Log相关methods"><a href="#Log相关methods" class="headerlink" title="Log相关methods"></a>Log相关methods</h5><p>这部分我们有机会单独讲。它们和Project1关系很小， 不知道它们的存在，也可以完成Project1。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Append a log entry to the log file.</span></span><br><span class="line"><span class="comment">* @param log_data raw log data</span></span><br><span class="line"><span class="comment">* @param size size of log entry</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteLog</span><span class="params">(<span class="keyword">char</span> *log_data, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Read a log entry from the log file.</span></span><br><span class="line"><span class="comment">* @param[out] log_data output buffer</span></span><br><span class="line"><span class="comment">* @param size size of the log entry</span></span><br><span class="line"><span class="comment">* @param offset offset of the log entry in the file</span></span><br><span class="line"><span class="comment">* @return true if the read was successful, false otherwise</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ReadLog</span><span class="params">(<span class="keyword">char</span> *log_data, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Sets the future which is used to check for non-blocking flushes.</span></span><br><span class="line"><span class="comment">* @param f the non-blocking flush check</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SetFlushLogFuture</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">void</span>&gt; *f)</span> </span>{ flush_log_f_ = f; }</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Checks if the non-blocking flush future was set. */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">HasFlushLogFuture</span><span class="params">()</span> </span>{ <span class="keyword">return</span> flush_log_f_ != <span class="literal">nullptr</span>; }</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @return true iff the in-memory content has not been flushed yet */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetFlushState</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @return the number of disk flushes */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNumFlushes</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> num_flushes_; }</span><br></pre></td></tr></tbody></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>我们在这篇文章最开始的时候介绍了Disk Manager的接口和服务，我们现在用代码层面去总结一下Disk Manager:</p><ul><li><code>DiskManager(const std::string &amp;db_file);</code>: 构造函数只需要一个文件名, 它主要使用<code>std::fstream::open</code>，对应的mode是<code>std::ios::binary | std::ios::trunc | std::ios::out</code></li><li><code>page_id_t AllocatePage()；</code>: 在磁盘上的文件分配一个新的page</li><li><code>void DeallocatePage(page_id_t page_id);</code>: 在磁盘上的文件回收一个page</li><li><code>void ReadPage(page_id_t page_id, char *page_data);</code>: 将page(文件上对应的部分)读入<code>page_data</code></li><li><code>void WritePage(page_id_t page_id, const char *page_data);</code>: 将<code>page_data</code>写入page(文件上对应的部分)</li><li><code>void ShutDown();</code>， <code>int GetFileSize(const std::string &amp;file_name);</code>， <code>int GetNumWrites() const;</code>: 均为简单的实现</li><li>(我们回避了Log的部分)</li></ul><h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><ul><li><code>std::fstream</code> 并不是线程安全的: <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIwMjEyMTU1LzEwOTcxNjUw" title="https://stackoverflow.com/a/20212155/10971650">https://stackoverflow.com/a/20212155/10971650<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuLXN0ZC5vcmcvanRjMS9zYzIyL3dnMjEvZG9jcy9wYXBlcnMvMjAwOC9uMjc2MC5odG0=" title="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2760.htm">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2760.htm<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9mb3J1bS8jIXRvcGljL2NvbXAudW5peC5zb2xhcmlzL2JCX3RnRldYTElZ" title="https://groups.google.com/forum/#!topic/comp.unix.solaris/bB_tgFWXLIY">https://groups.google.com/forum/#!topic/comp.unix.solaris/bB_tgFWXLIY<i class="fa fa-external-link"></i></span><ul><li><code>ReadPage</code>，<code>WritePage</code>不是线程安全的</li></ul></li><li>从实现上看<code>AllocatePage</code>和<code>DeallocatePage</code>是线程安全的</li></ul><p><br></p><ul><li>因此buffer manager需要给disk manager上一把线程锁<ul><li>最好是disk manager单独拥有一把锁，用于read write, 因为这些I/O需要时间很久。在这些I/O发生的时间里面，我们最好能继续使用buffer manager去做一些和disk manager(的线程锁)无关的事情，提高buffer manager的并行程度。</li></ul></li></ul><h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="comment">// 0. Init a disk manager to create a temporary file  </span></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> db_name = <span class="string">"test.db"</span>;</span><br><span class="line">  <span class="keyword">auto</span> *disk_manager = <span class="keyword">new</span> DiskManager(db_name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. Use disk_manager to do the work</span></span><br><span class="line">  <span class="comment">//    here can be multithreading - but use a mutex to do write+read</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. All threads joined here</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. Shutdown the disk manager and remove the temporary file we created.</span></span><br><span class="line">  disk_manager-&gt;ShutDown();</span><br><span class="line">  <span class="built_in">remove</span>(<span class="string">"test.db"</span>);</span><br><span class="line">  <span class="keyword">delete</span> disk_manager;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p>引用:</p><ul><li>Database Implementation For Modern Hardware. Chapter 2: Storage - Thomas Neumann: <span class="exturl" data-url="aHR0cHM6Ly9kYi5pbi50dW0uZGUvdGVhY2hpbmcvc3MyMC9tb2Rlcm5kYnMvY2hhcHRlcjIucGRmP2xhbmc9ZGU=" title="https://db.in.tum.de/teaching/ss20/moderndbs/chapter2.pdf?lang=de">https://db.in.tum.de/teaching/ss20/moderndbs/chapter2.pdf?lang=de<i class="fa fa-external-link"></i></span></li><li>Bustub - CMU Database Group: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NtdS1kYi9idXN0dWI=" title="https://github.com/cmu-db/bustub">https://github.com/cmu-db/bustub<i class="fa fa-external-link"></i></span></li></ul><p>推荐的阅读:</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTI2ODMwNy90aHJlYWQtc2FmZXR5LW9mLXJlYWQtcHJlYWQtc3lzdGVtLWNhbGxzLzUyNjg1NzgjNTI2ODU3OA==" title="https://stackoverflow.com/questions/5268307/thread-safety-of-read-pread-system-calls/5268578#5268578">https://stackoverflow.com/questions/5268307/thread-safety-of-read-pread-system-calls/5268578#5268578<i class="fa fa-external-link"></i></span></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Disk Manager是数据库中对磁盘文件操作的抽象。它提供给Buffer Manager的粒度是一个page, 即它操作的最小单元是一个page。而操作可以分为allocation分配和deallocation释放。&lt;/p&gt;
&lt;p&gt;在CMU Bustub中Disk Manager总是针对一个文件，每次从它上面获得或者写入page大小的数据量。Bustub是模拟SQLite, 而SQLite作为一个简单的数据库，只操作一个文件。当然其他复杂的数据集需要操作多个文件，那对应的Disk Manager需要去对应多个文件(open, read, write, close等操作)。我们下次有机会去考虑一下这样多文件的Disk Manger如何实现。而这次我们先打好基础，去理解CMU Bustub中单文件的Disk Manager。&lt;/p&gt;
&lt;p&gt;另外这篇文章中不关注Log。它需要之后单独描述。我们会区分Log(也对应一个文件)和File，File指那个特定的我们想读取和写入的文件。&lt;/p&gt;
&lt;p&gt;(另外CMU Bustub中的Disk Manager和CMU 17Fall 18Fall对应项目的Disk Manager没有区别)&lt;/p&gt;
    
    </summary>
    
    
      <category term="CMU-15445" scheme="https://cakebytheoceanluo.github.io/categories/CMU-15445/"/>
    
      <category term="Storage" scheme="https://cakebytheoceanluo.github.io/categories/Storage/"/>
    
      <category term="Buffer Management" scheme="https://cakebytheoceanluo.github.io/categories/Buffer-Management/"/>
    
    
      <category term="Disk Manager" scheme="https://cakebytheoceanluo.github.io/tags/Disk-Manager/"/>
    
  </entry>
  
  <entry>
    <title>[CMU-15445]17_18_Project1_2</title>
    <link href="https://cakebytheoceanluo.github.io/2020/05/20/CMU-15445-17-18-Project1-2/"/>
    <id>https://cakebytheoceanluo.github.io/2020/05/20/CMU-15445-17-18-Project1-2/</id>
    <published>2020-05-20T11:40:46.000Z</published>
    <updated>2020-08-17T13:01:26.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>我摘抄题目的重点:</p><ul><li>This is a generic class that is used to keep track of when elements that it is tracking are used. You will need to implement the least-recently used policy discussed in the class and the textbook.</li><li>It is up to you to decide how you want to implement the data structures to store the meta-data about the elements inside of <code>LRUReplacer</code>. For example, you can use the <code>ExtendibleHashTable</code> that you built in the first task or use a built-in STL container. </li><li>You do not need to worry about a maximun size of the data structures. You can assume that you will not run out of memory. Again, you need to make sure that the operations are thread-safe.</li><li>我对比过这部分的Fall2017的源代码和Fall2018没有区别， Fall2018多了一个test: <code>ConcurrencyTest</code></li></ul><a id="more"></a><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>我强烈建议大家先去做Leetcode上的LRU题，对应的文章我列在这里:</p><ul><li>Leetcode 146: <a href="https://cakebytheoceanluo.github.io/2020/04/20/Leetcode-Algo-146-lru-cache/">[Leetcode-Algorithm] 146.lru-cache</a>, <a href="https://cakebytheoceanluo.github.io/2020/04/19/std-list-splice/">https://cakebytheoceanluo.github.io/2020/04/19/std-list-splice/</a></li><li>LRU 解释的文章: <a href="https://cakebytheoceanluo.github.io/2020/04/26/LRU%E7%BB%83%E4%B9%A0/">LRU 练习</a>, <a href="https://cakebytheoceanluo.github.io/2020/04/23/cache-page-replacement/">Cache replacement policies &amp; Page replacement algorithm</a>, </li></ul><p>我不再这里赘述，实现起来没有很大区别。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="LRUReplacer"><a href="#LRUReplacer" class="headerlink" title="LRUReplacer"></a><code>LRUReplacer</code></h2><p>这部分难度不是很大，我就不再描述了。</p><h3 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; lru_list;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;T, <span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt;::iterator&gt; ht;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::shared_mutex latch;</span><br></pre></td></tr></tbody></table></figure><ul><li>具体描述见:  <a href="https://cakebytheoceanluo.github.io/2020/04/20/Leetcode-Algo-146-lru-cache/">[Leetcode-Algorithm] 146.lru-cache</a></li><li>我看很多人自己手写了一个double linked list，这当然不难。但是我个人觉得<code>std::list</code>更好， 因为std的<strong>iterator</strong>可以直接作为hash tabled value。当然也可以使用<code>std::deque</code>。但是:<ul><li><code>std::deque</code>没有splice方法</li><li><code>std::deque</code>在<code>emplace</code>和<code>insert</code>等系列方法后迭代器失效。那么比较难同时使用<code>std::unordered_map</code>, 至少不是这样的类型:  <code>std::unordered_map&lt;T, typename std::deque&lt;T&gt;::iterator&gt;</code><blockquote><p>There are still a few inaccuracies in this section, refer to individual member function pages for more detail. […]<br><span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2NvbnRhaW5lci9kZXF1ZQ==" title="https://en.cppreference.com/w/cpp/container/deque">https://en.cppreference.com/w/cpp/container/deque<i class="fa fa-external-link"></i></span></p></blockquote></li><li>最重要的是<code>std::list</code>的iterator不会因为insert, erase而invalid。这个点很吸引人。我经常使用<code>std::list</code>搭配<code>std::unordered_map</code>, 例如我们可以完成这里的LRU, 也可以通过类似的方式完成two queue(或许我们以后会提到)。<blockquote><p>Adding, removing and moving the elements within the list or across several lists does not invalidate the iterators or references. An iterator is invalidated only when the corresponding element is deleted.<br><span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2NvbnRhaW5lci9saXN0" title="https://en.cppreference.com/w/cpp/container/list">https://en.cppreference.com/w/cpp/container/list<i class="fa fa-external-link"></i></span></p></blockquote></li></ul></li></ul><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a><code>Insert</code></h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Insert value into LRU</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> LRUReplacer&lt;T&gt;::Insert(<span class="keyword">const</span> T &amp;value) {</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::shared_mutex&gt; <span class="title">lockGuard</span><span class="params">(latch)</span></span>;</span><br><span class="line">  assert(ht.<span class="built_in">size</span>() == lru_list.<span class="built_in">size</span>());</span><br><span class="line">  <span class="comment">// 1. Check if the value already there</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> got = ht.<span class="built_in">find</span>(value);</span><br><span class="line">  <span class="keyword">if</span> (got == ht.<span class="built_in">end</span>()) {</span><br><span class="line">    <span class="comment">// 2.1 value no there, then insert it</span></span><br><span class="line">    lru_list.emplace_front(value);</span><br><span class="line">    ht.emplace(value, lru_list.<span class="built_in">begin</span>());</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// 2.2 value already there, adjust the LRU list</span></span><br><span class="line">    lru_list.splice(lru_list.<span class="built_in">begin</span>(), lru_list, got-&gt;second);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Victim"><a href="#Victim" class="headerlink" title="Victim"></a><code>Victim</code></h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If LRU is non-empty, pop the head member from LRU to argument "value", and</span></span><br><span class="line"><span class="comment"> * return true. If LRU is empty, return false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> LRUReplacer&lt;T&gt;::Victim(T &amp;value) {</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::shared_mutex&gt; <span class="title">lockGuard</span><span class="params">(latch)</span></span>;</span><br><span class="line">  <span class="comment">// 0. Check the size, if any can be victimized</span></span><br><span class="line">  <span class="keyword">if</span> (ht.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  assert(ht.<span class="built_in">size</span>() == lru_list.<span class="built_in">size</span>());</span><br><span class="line">  <span class="comment">// 1. Pop from the end of the list</span></span><br><span class="line">  value = lru_list.back();</span><br><span class="line">  lru_list.pop_back();</span><br><span class="line">  <span class="comment">// 2. Erase from the hash table</span></span><br><span class="line">  ht.erase(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Erase"><a href="#Erase" class="headerlink" title="Erase"></a><code>Erase</code></h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Remove value from LRU. If removal is successful, return true, otherwise</span></span><br><span class="line"><span class="comment"> * return false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> LRUReplacer&lt;T&gt;::Erase(<span class="keyword">const</span> T &amp;value) {</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::shared_mutex&gt; <span class="title">lockGuard</span><span class="params">(latch)</span></span>;</span><br><span class="line">  assert(ht.<span class="built_in">size</span>() == lru_list.<span class="built_in">size</span>());</span><br><span class="line">  <span class="comment">// 1. Check if the value already there</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> got = ht.<span class="built_in">find</span>(value);</span><br><span class="line">  <span class="keyword">if</span> (got == ht.<span class="built_in">end</span>()) {</span><br><span class="line">    <span class="comment">// 2.1 value no there, do nothing</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// 2.2 value already there, erase from the LRU list and the hash table</span></span><br><span class="line">    lru_list.erase(got-&gt;second);</span><br><span class="line">    ht.erase(got);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nha2VieXRoZW9jZWFuTHVvL0NNVTE1LTQ0NS0yMDE3L2Jsb2IvbWFzdGVyL3Rlc3QvYnVmZmVyL2xydV9yZXBsYWNlcl90ZXN0LmNwcA==" title="https://github.com/cakebytheoceanLuo/CMU15-445-2017/blob/master/test/buffer/lru_replacer_test.cpp">https://github.com/cakebytheoceanLuo/CMU15-445-2017/blob/master/test/buffer/lru_replacer_test.cpp<i class="fa fa-external-link"></i></span></li></ul><p>我准备了非常丰富的多线程的test，它们能检查线程是否安全，同时也是对锁粒度和性能的考验(如果性能太差会需要很长时间):</p><ul><li><code>ConcurrentInsertTest</code></li><li><code>ConcurrentMultiInsertTest</code></li><li><code>ConcurrentEraseTest</code></li><li><code>ConcurrentVictimTest</code></li><li><code>ConcurrentMixedTest</code></li></ul><h1 id="MY-TODO"><a href="#MY-TODO" class="headerlink" title="MY-TODO"></a>MY-TODO</h1><ul><li>尝试使用<code>std::deque</code>, 比较实现细节和性能:<ul><li>见 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xhbmNlY29wcGVyL2NtdTE1NDQ1X2ZhbGwyMDE3L2Jsb2IvbWFzdGVyL3NxbGl0ZS1mYWxsMjAxNy9zcmMvYnVmZmVyL2xydV9yZXBsYWNlci5jcHA=" title="https://github.com/lancecopper/cmu15445_fall2017/blob/master/sqlite-fall2017/src/buffer/lru_replacer.cpp">https://github.com/lancecopper/cmu15445_fall2017/blob/master/sqlite-fall2017/src/buffer/lru_replacer.cpp<i class="fa fa-external-link"></i></span></li><li>见 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0JyYWdDYXQvQ01VLTE1NDQ1LURCL2Jsb2IvbWFzdGVyL3NyYy9pbmNsdWRlL2J1ZmZlci9scnVfcmVwbGFjZXIuaA==" title="https://github.com/BragCat/CMU-15445-DB/blob/master/src/include/buffer/lru_replacer.h">https://github.com/BragCat/CMU-15445-DB/blob/master/src/include/buffer/lru_replacer.h<i class="fa fa-external-link"></i></span></li><li>(实现中没有使用hash table)</li></ul></li></ul><hr><p>引用:</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMTgvcHJvamVjdDEv" title="https://15445.courses.cs.cmu.edu/fall2018/project1/">https://15445.courses.cs.cmu.edu/fall2018/project1/<i class="fa fa-external-link"></i></span></li></ul><p>推荐的阅读:</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdS1qaWFuaGFvL0NNVS0xNS00NDUvdHJlZS9tYXN0ZXIvTGFiMS1CdWZmZXItUG9vbCMlRTUlOEYlQUYlRTYlODklQTklRTUlQjElOTUlRTclOUElODQlRTUlOTMlODglRTUlQjglOEMlRTglQTElQTg=" title="https://github.com/liu-jianhao/CMU-15-445/tree/master/Lab1-Buffer-Pool#%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8">https://github.com/liu-jianhao/CMU-15-445/tree/master/Lab1-Buffer-Pool#%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ2F0c2J5MTIzL3AvMTA2MTMxNjAuaHRtbA==" title="https://www.cnblogs.com/gatsby123/p/10613160.html">https://www.cnblogs.com/gatsby123/p/10613160.html<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9lZGUwODlkM2Q4YWQ=" title="https://www.jianshu.com/p/ede089d3d8ad">https://www.jianshu.com/p/ede089d3d8ad<i class="fa fa-external-link"></i></span></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;我摘抄题目的重点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This is a generic class that is used to keep track of when elements that it is tracking are used. You will need to implement the least-recently used policy discussed in the class and the textbook.&lt;/li&gt;
&lt;li&gt;It is up to you to decide how you want to implement the data structures to store the meta-data about the elements inside of &lt;code&gt;LRUReplacer&lt;/code&gt;. For example, you can use the &lt;code&gt;ExtendibleHashTable&lt;/code&gt; that you built in the first task or use a built-in STL container. &lt;/li&gt;
&lt;li&gt;You do not need to worry about a maximun size of the data structures. You can assume that you will not run out of memory. Again, you need to make sure that the operations are thread-safe.&lt;/li&gt;
&lt;li&gt;我对比过这部分的Fall2017的源代码和Fall2018没有区别， Fall2018多了一个test: &lt;code&gt;ConcurrencyTest&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="CMU-15445" scheme="https://cakebytheoceanluo.github.io/categories/CMU-15445/"/>
    
      <category term="Data Structure" scheme="https://cakebytheoceanluo.github.io/categories/Data-Structure/"/>
    
      <category term="Algorithm" scheme="https://cakebytheoceanluo.github.io/categories/Algorithm/"/>
    
    
      <category term="Page" scheme="https://cakebytheoceanluo.github.io/tags/Page/"/>
    
      <category term="LRU" scheme="https://cakebytheoceanluo.github.io/tags/LRU/"/>
    
      <category term="Cache" scheme="https://cakebytheoceanluo.github.io/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>LRU练习</title>
    <link href="https://cakebytheoceanluo.github.io/2020/04/26/LRU%E7%BB%83%E4%B9%A0/"/>
    <id>https://cakebytheoceanluo.github.io/2020/04/26/LRU%E7%BB%83%E4%B9%A0/</id>
    <published>2020-04-26T16:45:24.000Z</published>
    <updated>2020-10-16T08:46:21.033Z</updated>
    
    <content type="html"><![CDATA[<p>最近最少使用算法(LRU, Least Recently Used)选择最近最少使用的内容作为替换对象。LRU是一种缓存文件置换机制，即电脑处理缓存存储器的一种机制。电脑存储器空间的大小固定，无法容纳服务器上所有的文件，所以当有新的文件要被置换入缓存时，必须根据一定的原则来取代掉适当的文件。此原则即所谓缓存文件置换机制。<sup><a href="#fn1">1</a></sup></p><p>这篇文章中我们模糊Cache replacement policies和Page replacement algorithm这两个概念,而主要注意在<strong>Cache replacement policies</strong>。有关的区别:</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FjaGVfcmVwbGFjZW1lbnRfcG9saWNpZXM=" title="https://en.wikipedia.org/wiki/Cache_replacement_policies">https://en.wikipedia.org/wiki/Cache_replacement_policies<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGFnZV9yZXBsYWNlbWVudF9hbGdvcml0aG0=" title="https://en.wikipedia.org/wiki/Page_replacement_algorithm">https://en.wikipedia.org/wiki/Page_replacement_algorithm<i class="fa fa-external-link"></i></span></li></ul><p><br></p><ul><li><a href="https://cakebytheoceanluo.github.io/2020/04/20/Leetcode-Algo-146-lru-cache/">[Leetcode-Algorithm] 146.lru-cache</a></li></ul><a id="more"></a><h1 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h1><p>首先替换最近最少使用的元素。LRU算法踪何时使用了哪个元素。确保算法始终替换最近最少使用的元素，这中操作是非常昂贵的。因为要从操作系统中获取时间是一个很贵的操作，不管是software timer还是hardware timer。细讲一下, 从hardware timer获取时间会更加昂贵，因为需要更多的hardware interrupt和TRAP进操作系统的kernel。这是因为这个原因，实现上会采用LRU的近似，而不是严格比较时间点(timestamp)。</p><p>General implementations of this technique require keeping “age bits” for cache-lines and track the “Least Recently Used” cache-line based on age-bits. In such an implementation, every time a cache-line is used, the age of all other cache-lines changes. LRU is actually a family of caching algorithms with members including 2Q by Theodore Johnson and Dennis Shasha, and LRU/K by Pat O’Neil, Betty O’Neil and Gerhard Weikum。<sup><a href="#fn2">2</a></sup></p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="wiki例子-2"><a href="#wiki例子-2" class="headerlink" title="wiki例子 2"></a>wiki例子 <sup><a href="#fn2">2</a></sup></h2><p>访问的顺序是:  <code>A B C D E D F</code></p><p><img data-src="https://upload.wikimedia.org/wikipedia/commons/8/88/Lruexample.png" alt="wiki例子"></p><ul><li><code>E</code>被访问时: cache miss发生, 最近最少使用的<code>A</code>被替换成<code>E</code></li><li><code>F</code>被访问时: cache miss发生, 最近最少使用的<code>B</code>被替换成<code>F</code></li></ul><h2 id="例子一-3"><a href="#例子一-3" class="headerlink" title="例子一 3"></a>例子一 <sup><a href="#fn3">3</a></sup></h2><p>访问的顺序是:  <code>7 0 1 2 0 3 0 4</code>, 另外cache的容量是3</p><p><img data-src="https://cakebytheoceanluo.github.io/images/Algo/LRU_0.png" alt="例子图"></p><ul><li>上图中先后顺序由队列中顺序显示<ul><li>新加入的元素在队列上面 <code>list.head</code></li><li>后加入的元素在队列下面 <code>list.tail</code></li></ul></li></ul><h2 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h2><p>访问的顺序是(即图中的<code>Anfrage</code>列): <code>1 3 5 4 2 4 3 2 1 0 5 3</code>, 另外cache的容量在下面第一张图中是4, 在第二张图中是5:</p><p><img data-src="https://cakebytheoceanluo.github.io/images/Algo/LRU_1.png" alt="LRU_1"></p><p><img data-src="https://cakebytheoceanluo.github.io/images/Algo/LRU_2.png" alt="LRU_2"></p><p>由于LRU, 我们存储了元素的id，还需要存储该元素最近被访问的时间点， 即图中的<code>(element id, access time)</code>这个对。另外<code>Nr Pagefaults</code>指的是直到当前page fault出现的总次数。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>具体实现见　</p><ul><li><a href="https://cakebytheoceanluo.github.io/2020/04/20/Leetcode-Algo-146-lru-cache/">[Leetcode-Algorithm] 146.lru-cache</a><!-- - CMU TODO: --></li></ul><h1 id="Modern-Operating-Systems读书笔记-4"><a href="#Modern-Operating-Systems读书笔记-4" class="headerlink" title="Modern Operating Systems读书笔记 4"></a>Modern Operating Systems读书笔记 <sup><a href="#fn4">4</a></sup></h1><p>A good approximation to the <strong>optimal algorithm</strong> is based on the observation that pages that have been heavily used in the last few instructions will probably be heavily used again soon. Conversely, pages that have not been used for ages will probably remain unused for a long time. This idea suggests a realizable algorithm: when a page fault occurs, throw out the page that has been unused for the longest time. This strategy is called <strong>LRU (Least Recently Used) paging</strong>.</p><p>LRU is theoretically realizable but <strong>not cheap</strong> by a long shot: </p><ul><li>To fully implement LRU, it is necessary to maintain a linked list of all pages in memory, with the most recently used page at the front and the least recently used page at the rear. </li><li>The difficulty is that the list must be updated on every memory reference. Finding a page in the list, deleting it, and then moving it to the front is <strong>a very time consuming operation, even in hardware (assuming that such hardware could be built)</strong></li></ul><p>However, there are other ways to implement LRU with special hardware. Let us consider the simplest way first:</p><ul><li>This method requires equipping the hardware with a 64-bit counter, <em>C</em>, that is automatically incremented after each instruction.</li><li>Furthermore, each page table entry must also have a field large enough to contain the counter. After each memory reference, the current value of <em>C</em> is stored in the page table entry for the page just referenced. </li><li>When a page fault occurs, the operating system examines all the counters in the page table to find the lowest one. That page is the least recently used.</li></ul><!-- TODO: 3.4.7 Simulating LRU in Software --><hr><p>引用: </p><p><a name="fn1">1</a>: <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUJGJUFCJUU1JThGJTk2JUU2JTk2JTg3JUU0JUJCJUI2JUU3JUJEJUFFJUU2JThGJTlCJUU2JUE5JTlGJUU1JTg4JUI2" title="https://zh.wikipedia.org/wiki/%E5%BF%AB%E5%8F%96%E6%96%87%E4%BB%B6%E7%BD%AE%E6%8F%9B%E6%A9%9F%E5%88%B6">https://zh.wikipedia.org/wiki/%E5%BF%AB%E5%8F%96%E6%96%87%E4%BB%B6%E7%BD%AE%E6%8F%9B%E6%A9%9F%E5%88%B6<i class="fa fa-external-link"></i></span></p><p><a name="fn2">2</a>: <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FjaGVfcmVwbGFjZW1lbnRfcG9saWNpZXMjTGVhc3RfcmVjZW50bHlfdXNlZF8oTFJV" title="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU">https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU<i class="fa fa-external-link"></i></span>)</p><p><a name="fn3">3</a>: <span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83NGE0ZWZhY2IwYTc=" title="https://www.jianshu.com/p/74a4efacb0a7">https://www.jianshu.com/p/74a4efacb0a7<i class="fa fa-external-link"></i></span></p><p><a name="fn4">4</a>: Modern Operating Systems 4th Edition - Andrew Tanenbaum  - 3.4.6 The Least Recently Used (LRU) Page Replacement Algorithm</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近最少使用算法(LRU, Least Recently Used)选择最近最少使用的内容作为替换对象。LRU是一种缓存文件置换机制，即电脑处理缓存存储器的一种机制。电脑存储器空间的大小固定，无法容纳服务器上所有的文件，所以当有新的文件要被置换入缓存时，必须根据一定的原则来取代掉适当的文件。此原则即所谓缓存文件置换机制。&lt;sup&gt;&lt;a href=&quot;#fn1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;这篇文章中我们模糊Cache replacement policies和Page replacement algorithm这两个概念,而主要注意在&lt;strong&gt;Cache replacement policies&lt;/strong&gt;。有关的区别:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FjaGVfcmVwbGFjZW1lbnRfcG9saWNpZXM=&quot; title=&quot;https://en.wikipedia.org/wiki/Cache_replacement_policies&quot;&gt;https://en.wikipedia.org/wiki/Cache_replacement_policies&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGFnZV9yZXBsYWNlbWVudF9hbGdvcml0aG0=&quot; title=&quot;https://en.wikipedia.org/wiki/Page_replacement_algorithm&quot;&gt;https://en.wikipedia.org/wiki/Page_replacement_algorithm&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cakebytheoceanluo.github.io/2020/04/20/Leetcode-Algo-146-lru-cache/&quot;&gt;[Leetcode-Algorithm] 146.lru-cache&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://cakebytheoceanluo.github.io/categories/Algorithm/"/>
    
    
      <category term="Page" scheme="https://cakebytheoceanluo.github.io/tags/Page/"/>
    
      <category term="LRU" scheme="https://cakebytheoceanluo.github.io/tags/LRU/"/>
    
      <category term="Cache" scheme="https://cakebytheoceanluo.github.io/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>Cache replacement policies &amp; Page replacement algorithm</title>
    <link href="https://cakebytheoceanluo.github.io/2020/04/23/cache-page-replacement/"/>
    <id>https://cakebytheoceanluo.github.io/2020/04/23/cache-page-replacement/</id>
    <published>2020-04-23T21:51:16.000Z</published>
    <updated>2020-04-26T16:54:07.374Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章中我们<strong>区分</strong>Cache replacement policies和Page replacement algorithm这两个概念:</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FjaGVfcmVwbGFjZW1lbnRfcG9saWNpZXM=" title="https://en.wikipedia.org/wiki/Cache_replacement_policies">https://en.wikipedia.org/wiki/Cache_replacement_policies<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGFnZV9yZXBsYWNlbWVudF9hbGdvcml0aG0=" title="https://en.wikipedia.org/wiki/Page_replacement_algorithm">https://en.wikipedia.org/wiki/Page_replacement_algorithm<i class="fa fa-external-link"></i></span></li></ul><a id="more"></a><h1 id="Cache-replacement-policies-缓存文件置换机制"><a href="#Cache-replacement-policies-缓存文件置换机制" class="headerlink" title="Cache replacement policies 缓存文件置换机制"></a>Cache replacement policies 缓存文件置换机制</h1><p>Cache replacement policies是指<strong>普遍</strong>的缓存算法，不针对一种硬件，也不针对存储的形式。 cache algorithms, cache replacement algorithms, cache replacement policies都是同义词。</p><p>In computing, <strong>cache algorithms</strong> are optimizing instructions or algorithms, that a computer program or a hardware-maintained structure can utilize in order to manage a cache of information stored on the computer. <strong>Caching improves performance by keeping recent or often-used data items in memory locations that are faster or computationally cheaper to access than normal memory stores.</strong> When the cache is full, the algorithm must choose which items to discard to make room for the new ones.<sup><a href="#fn1">1</a></sup></p><p>(缓存文件置换机制是电脑处理缓存存储器的一种机制。电脑存储器空间的大小固定，无法容纳服务器上所有的文件，所以当有新的文件要被置换入缓存时，必须根据一定的原则来取代掉适当的文件。此原则即所谓缓存文件置换机制。<sup><a href="#fn2">2</a></sup>)</p><p>缓存文件置换方法有:</p><ul><li>FIFO</li><li>LFU</li><li>LRU<ul><li><a href="https://cakebytheoceanluo.github.io/2020/04/26/LRU%E7%BB%83%E4%B9%A0/">LRU 练习</a></li><li><a href="https://cakebytheoceanluo.github.io/2020/04/20/Leetcode-Algo-146-lru-cache/">[Leetcode-Algorithm] 146.lru-cache</a></li></ul></li><li>NMRU</li><li>…</li></ul><h1 id="Page-replacement-algorithm-页面置换算法"><a href="#Page-replacement-algorithm-页面置换算法" class="headerlink" title="Page replacement algorithm 页面置换算法"></a>Page replacement algorithm 页面置换算法</h1><p>Page replacement algorithm是一种<strong>特殊</strong>的缓存算法，指内存和硬盘之间的缓存，而缓存的最小单位是一个page页。它应用于操作系统和数据库管理系统中。在具体的操作系统或者数据库语境中，页面置换算法会变得不再理论，而需要非常实现相关，因为实际中页面置换算法的使用率非常高，可以类比人类的呼吸一样频发，因此需要高效的实现。</p><p>为提高内存利用率，解决内存供不应求的问题，更加合理的使用内存，人们创造了分页式内存抽象。同时有一个虚拟内存的概念，是指将内存中暂时不需要的部分写入硬盘，看上去硬盘扩展了内存的容量，所以叫做“虚拟”内存。使用虚拟内存，应用程序可以使用比实际物理内存更大的内存空间。可以认为这个更大的内存空间就在硬盘上，只有将某一部分需要被用到时，才被写入真实内存；当它暂时不再被用到时，又被写回硬盘。分页式内存管理将物理内存分为等大的小块，每块大小通常为1K、2K、4K等，称为页帧；逻辑内存(使用虚拟内存技术扩大的内存，可认为其位于硬盘上)也被分为等大的小块，称为页；且页和页帧的大小一定是一样的，它是写入真实内存和写回硬盘最小单位。<sup><a href="#fn3">3</a></sup></p><p>页面置换算法: 在地址映射过程中，如果发现所要访问的页page不在内存中，则产生page fault。当发生page fault时，如果操作系统内存中没有空闲页，则操作系统必须在内存选择一个页将其移出内存，以便为即将调入的页面让出空间。而具体选择哪一个页面由页面置换算法决定，具体的影响因素也因页面置换算法的不同而不同。</p><p>页面置换算法依旧是缓存文件置换算法的具体实现，而且最小单位变成了一个页page。</p><p><br></p><p>In a computer operating system that uses paging for virtual memory management, <strong>page replacement algorithms decide which memory pages to page out,</strong> sometimes called swap out, or write to disk, when a page of memory needs to be allocated. <strong>Page replacement happens when a requested page is not in memory (page fault) and a free page cannot be used to satisfy the allocation</strong>, either because there are none, or because the number of free pages is lower than some threshold.</p><p>When the page that was selected for replacement and paged out is referenced again it has to be paged in (read in from disk), and this involves waiting for I/O completion. This determines the quality of the page replacement algorithm: the less time waiting for page-ins, the better the algorithm. A page replacement algorithm looks at the limited information about accesses to the pages provided by hardware, and tries to guess which pages should be replaced to minimize the total number of page misses, while balancing this with the costs (primary storage and processor time) of the algorithm itself.</p><p>The page replacing problem is a typical <em>online problem</em> from the competitive analysis perspective in the sense that the optimal deterministic algorithm is known.</p><p><a name="fn1">1</a>: <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FjaGVfcmVwbGFjZW1lbnRfcG9saWNpZXM=" title="https://en.wikipedia.org/wiki/Cache_replacement_policies">https://en.wikipedia.org/wiki/Cache_replacement_policies<i class="fa fa-external-link"></i></span></p><p><a name="fn2">2</a>: <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUJGJUFCJUU1JThGJTk2JUU2JTk2JTg3JUU0JUJCJUI2JUU3JUJEJUFFJUU2JThGJTlCJUU2JUE5JTlGJUU1JTg4JUI2" title="https://zh.wikipedia.org/wiki/%E5%BF%AB%E5%8F%96%E6%96%87%E4%BB%B6%E7%BD%AE%E6%8F%9B%E6%A9%9F%E5%88%B6">https://zh.wikipedia.org/wiki/%E5%BF%AB%E5%8F%96%E6%96%87%E4%BB%B6%E7%BD%AE%E6%8F%9B%E6%A9%9F%E5%88%B6<i class="fa fa-external-link"></i></span></p><p><a name="fn3">3</a>: <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc2NoaXBzL3AvMTA5MjAxNDUuaHRtbA==" title="https://www.cnblogs.com/schips/p/10920145.html">https://www.cnblogs.com/schips/p/10920145.html<i class="fa fa-external-link"></i></span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章中我们&lt;strong&gt;区分&lt;/strong&gt;Cache replacement policies和Page replacement algorithm这两个概念:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FjaGVfcmVwbGFjZW1lbnRfcG9saWNpZXM=&quot; title=&quot;https://en.wikipedia.org/wiki/Cache_replacement_policies&quot;&gt;https://en.wikipedia.org/wiki/Cache_replacement_policies&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGFnZV9yZXBsYWNlbWVudF9hbGdvcml0aG0=&quot; title=&quot;https://en.wikipedia.org/wiki/Page_replacement_algorithm&quot;&gt;https://en.wikipedia.org/wiki/Page_replacement_algorithm&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://cakebytheoceanluo.github.io/categories/Algorithm/"/>
    
    
      <category term="Page" scheme="https://cakebytheoceanluo.github.io/tags/Page/"/>
    
      <category term="Cache" scheme="https://cakebytheoceanluo.github.io/tags/Cache/"/>
    
      <category term="Leetcode" scheme="https://cakebytheoceanluo.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode-Algorithm] 146.lru-cache</title>
    <link href="https://cakebytheoceanluo.github.io/2020/04/20/Leetcode-Algo-146-lru-cache/"/>
    <id>https://cakebytheoceanluo.github.io/2020/04/20/Leetcode-Algo-146-lru-cache/</id>
    <published>2020-04-20T19:08:50.000Z</published>
    <updated>2020-10-18T20:41:40.979Z</updated>
    
    <content type="html"><![CDATA[<p>146.LRU Cache</p><p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: <code>get</code> and <code>put</code>.</p><p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p><p>Follow up:<br>Could you do both operations in O(1) time complexity?</p><p>Example:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache = <span class="keyword">new</span> LRUCache( <span class="number">2</span> <span class="comment">/* capacity */</span> );</span><br><span class="line"></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">1</span>);       <span class="comment">// returns 1</span></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// evicts key 2</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">2</span>);       <span class="comment">// returns -1 (not found)</span></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// evicts key 1</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">1</span>);       <span class="comment">// returns -1 (not found)</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">3</span>);       <span class="comment">// returns 3</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">4</span>);       <span class="comment">// returns 4</span></span><br></pre></td></tr></tbody></table></figure><a id="more"></a><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>为了<code>put</code>和<code>get</code>有O(1)的时间复杂度，我们使用双向链表std::list和哈希表std::unordered_map作为cache的数据结构。std::list插入删除效率高, std::unordered_map保存每个节点的地址，可以基本保证在O(1)时间内查找节点。</p><p>这里的unordered_map的类型是: <code>std::unordered_map&lt;int, std::list&lt;std::pair&lt;int, int&gt;&gt;::iterator&gt;</code>。</p><ul><li>我尝试过使用<code>std::pair&lt;int, int&gt;*</code>作为value，但是效果不好。这是最合适的是使用list的iterator</li></ul><p><img data-src="/images/Leetcode/lru_1.png" alt="图片来源: https://www.jianshu.com/p/74a4efacb0a7"></p><p><img data-src="/images/Leetcode/lru_2.jpg" alt="图片来源: https://www.cnblogs.com/kyoner/p/11179766.html"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> {</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; l;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator&gt; ht;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) : capacity(capacity) {}; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>{</span><br><span class="line">        <span class="keyword">auto</span> got = ht.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (got != ht.<span class="built_in">end</span>()) {</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> result = got-&gt;second-&gt;second;</span><br><span class="line">            l.splice(l.<span class="built_in">begin</span>(), l, got-&gt;second);  <span class="comment">/// 把当前访问的节点移到链表头部</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">auto</span> got = ht.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (got != ht.<span class="built_in">end</span>()) {</span><br><span class="line">            got-&gt;second-&gt;second = value;</span><br><span class="line">            l.splice(l.<span class="built_in">begin</span>(), l, got-&gt;second);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">/// 删除链表尾部节点（最少访问的节点）</span></span><br><span class="line">            <span class="keyword">if</span> (ht.<span class="built_in">size</span>() == capacity) {</span><br><span class="line">                ht.erase(l.back().first);</span><br><span class="line">                l.pop_back();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">/// 插入新节点到链表头部</span></span><br><span class="line">            l.emplace_front(key, value);</span><br><span class="line">            ht[key] = l.<span class="built_in">begin</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><code>l.splice(l.begin(), l, got-&gt;second);</code> 可以替换为: <code>l.erase(got-&gt;second); l.emplace_front(key, result); ht[key] = l.begin();</code></li><li><p><code>put</code>也可以是:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> got = ht.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (got != ht.<span class="built_in">end</span>()) {</span><br><span class="line">        <span class="comment">/// 移除该一出现节点</span></span><br><span class="line">        l.erase(got-&gt;second);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">/// 删除链表尾部节点（最少访问的节点）</span></span><br><span class="line">        <span class="keyword">if</span> (ht.<span class="built_in">size</span>() == capacity) {</span><br><span class="line">            ht.erase(l.back().first);</span><br><span class="line">            l.pop_back();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/// 插入新节点到链表头部,并且更新map中增加该节点</span></span><br><span class="line">    l.emplace_front(key, value);</span><br><span class="line">    ht[key] = l.<span class="built_in">begin</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><a href="https://cakebytheoceanluo.github.io/2020/04/19/std-list-splice/">std::list::splice 详解</a></p></li></ul><p><br></p><p>引用和推荐的阅读：</p><p><a href="https://cakebytheoceanluo.github.io/2020/04/26/LRU%E7%BB%83%E4%B9%A0/">LRU 练习</a></p><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbHJ1LWNhY2hlLw==" title="https://leetcode.com/problems/lru-cache/">https://leetcode.com/problems/lru-cache/<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbHJ1LWNhY2hlL3NvbHV0aW9uL2xydWh1YW4tY3VuLWppLXpoaS1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=" title="https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/">https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vVGVub3NEb0l0L3AvMzQxNzE1Ny5odG1s" title="https://www.cnblogs.com/TenosDoIt/p/3417157.html">https://www.cnblogs.com/TenosDoIt/p/3417157.html<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vRGhvdXNlL3AvODYxNTQ4MS5odG1s" title="https://www.cnblogs.com/Dhouse/p/8615481.html">https://www.cnblogs.com/Dhouse/p/8615481.html<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNDEzMzA2Nw==" title="https://zhuanlan.zhihu.com/p/34133067">https://zhuanlan.zhihu.com/p/34133067<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83NGE0ZWZhY2IwYTc=" title="https://www.jianshu.com/p/74a4efacb0a7">https://www.jianshu.com/p/74a4efacb0a7<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va3lvbmVyL3AvMTExNzk3NjYuaHRtbA==" title="https://www.cnblogs.com/kyoner/p/11179766.html">https://www.cnblogs.com/kyoner/p/11179766.html<i class="fa fa-external-link"></i></span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;146.LRU Cache&lt;/p&gt;
&lt;p&gt;Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;get(key)&lt;/code&gt; - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.&lt;br&gt;&lt;code&gt;put(key, value)&lt;/code&gt; - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;Could you do both operations in O(1) time complexity?&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;LRUCache cache = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LRUCache( &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;/* capacity */&lt;/span&gt; );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.&lt;span class=&quot;built_in&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.&lt;span class=&quot;built_in&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.&lt;span class=&quot;built_in&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);       &lt;span class=&quot;comment&quot;&gt;// returns 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.&lt;span class=&quot;built_in&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);    &lt;span class=&quot;comment&quot;&gt;// evicts key 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.&lt;span class=&quot;built_in&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);       &lt;span class=&quot;comment&quot;&gt;// returns -1 (not found)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.&lt;span class=&quot;built_in&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);    &lt;span class=&quot;comment&quot;&gt;// evicts key 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.&lt;span class=&quot;built_in&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);       &lt;span class=&quot;comment&quot;&gt;// returns -1 (not found)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.&lt;span class=&quot;built_in&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);       &lt;span class=&quot;comment&quot;&gt;// returns 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.&lt;span class=&quot;built_in&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);       &lt;span class=&quot;comment&quot;&gt;// returns 4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://cakebytheoceanluo.github.io/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="https://cakebytheoceanluo.github.io/categories/Leetcode/"/>
    
    
      <category term="LRU" scheme="https://cakebytheoceanluo.github.io/tags/LRU/"/>
    
      <category term="Cache" scheme="https://cakebytheoceanluo.github.io/tags/Cache/"/>
    
      <category term="Leetcode" scheme="https://cakebytheoceanluo.github.io/tags/Leetcode/"/>
    
      <category term="C++" scheme="https://cakebytheoceanluo.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>std::list::splice详解</title>
    <link href="https://cakebytheoceanluo.github.io/2020/04/19/std-list-splice/"/>
    <id>https://cakebytheoceanluo.github.io/2020/04/19/std-list-splice/</id>
    <published>2020-04-19T21:17:24.000Z</published>
    <updated>2020-04-19T21:19:36.862Z</updated>
    
    <content type="html"><![CDATA[<p><code>std::list::splice</code>详解</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p><code>splice</code>方法将list的元素进行<strong>拼接合并</strong>，原理是改变结点指针的指向，属于常数的复杂度。这个方法是<code>std::list</code>特有的，它<strong>不需要复制拷贝</strong>，直接对同类型的list中的节点的指针进行操作。</p><p>list容器底层实现是一个带头结点的双向链表double linked list。由于list每个节点是单独的，所以list在随机插入和随机删除都是O(1)的复杂度。在list中移动数据或者两个list之间移动数据的时候，直接把节点摘下来，接入到新的位置就可以了，非常高效。</p><p><code>splice</code>方法有三种声明/作用/复杂度：</p><ol><li>entire list: <code>void splice ( iterator pos, list&amp; other );</code>　<ul><li>将list <code>other</code>中的元素全都移到caller container的position处</li><li><strong>复杂度: Constant</strong></li></ul></li><li>single element: <code>void splice ( iterator pos, list&amp; other, iterator it );</code><ul><li>仅将list <code>other</code>中的由迭代器it指向的元素移到caller container的position处</li><li><strong>复杂度: Constant</strong></li></ul></li><li>element range: <code>void splice ( iterator pos, list&amp; other, iterator first, iterator last );</code><ul><li>list <code>other</code>的迭代器区间 $[\mathrm{first}, \mathrm{last})$ 中的元素移动到caller container的position处</li><li><strong>复杂度: Constant if <code>other</code> refers to the same object as <code>*this</code>, otherwise linear in <code>std::distance(first, last)</code>.</strong> <sup><a href="#fn1">1</a></sup></li></ul></li></ol><p>caller container := 调用者容器</p><p>由此可见，<strong>这个方法总是将list <code>other</code>中元素移动(剪切)到caller container中。</strong></p><a id="more"></a><p><br></p><p>Transfers elements from one list to another. <strong>No elements are copied or moved</strong>, only the internal pointers of the list nodes are re-pointed. The behavior is undefined if: <code>get_allocator() != other.get_allocator()</code>.<sup><a href="#fn1">1</a></sup></p><p>具体参数见:</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY3BsdXNwbHVzLmNvbS9yZWZlcmVuY2UvbGlzdC9saXN0L3NwbGljZS8=" title="https://www.cplusplus.com/reference/list/list/splice/">https://www.cplusplus.com/reference/list/list/splice/<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2NvbnRhaW5lci9saXN0L3NwbGljZQ==" title="https://en.cppreference.com/w/cpp/container/list/splice">https://en.cppreference.com/w/cpp/container/list/splice<i class="fa fa-external-link"></i></span></li></ul><h1 id="例子一2"><a href="#例子一2" class="headerlink" title="例子一2"></a>例子一<sup><a href="#fn2">2</a></sup></h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// splicing lists</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist1, mylist2;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set some initial values:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">4</span>; ++i)</span><br><span class="line">     mylist1.push_back(i);      <span class="comment">// mylist1: 1 2 3 4</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; ++i)</span><br><span class="line">     mylist2.push_back(i*<span class="number">10</span>);   <span class="comment">// mylist2: 10 20 30</span></span><br><span class="line"></span><br><span class="line">  it = mylist1.<span class="built_in">begin</span>();</span><br><span class="line">  ++it;                         <span class="comment">// points to 2 in mylist1 (the 2th element)</span></span><br><span class="line"></span><br><span class="line">  mylist1.splice (it, mylist2); <span class="comment">// mylist1: 1 10 20 30 2 3 4</span></span><br><span class="line">                                <span class="comment">// mylist2 (empty)</span></span><br><span class="line">                                <span class="comment">// "it" still points to 2 in mylist1 (the 5th element)</span></span><br><span class="line">                                <span class="comment">// it由于是指向的mylist1, splice后，迭代器it依然存在于mylist1中，故而不失效</span></span><br><span class="line">                                          </span><br><span class="line">  mylist2.splice (mylist2.<span class="built_in">begin</span>(), mylist1, it);</span><br><span class="line">                                <span class="comment">// mylist1: 1 10 20 30 3 4</span></span><br><span class="line">                                <span class="comment">// mylist2: 2</span></span><br><span class="line">                                <span class="comment">// "it" is now VALID in mylist2, points to 2 (the 1st element).</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  it = mylist1.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="built_in">std</span>::advance(it,<span class="number">3</span>);           <span class="comment">// "it" points now to 30 in mylist1 (the 4th element)</span></span><br><span class="line">                                <span class="comment">// 注意此处mylist前后交换了，这可以用作list形如循环移位的操作</span></span><br><span class="line"></span><br><span class="line">  mylist1.splice ( mylist1.<span class="built_in">begin</span>(), mylist1, it, mylist1.<span class="built_in">end</span>());</span><br><span class="line">                                <span class="comment">// mylist1: 30 3 4 1 10 20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist1 contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (it=mylist1.<span class="built_in">begin</span>(); it!=mylist1.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist2 contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (it=mylist2.<span class="built_in">begin</span>(); it!=mylist2.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mylist1 contains: 30 3 4 1 10 20</span><br><span class="line">mylist2 contains: 2</span><br></pre></td></tr></tbody></table></figure><h1 id="对splice后的iterator的研究"><a href="#对splice后的iterator的研究" class="headerlink" title="对splice后的iterator的研究"></a>对<code>splice</code>后的iterator的研究</h1><p>我们关注<a href="#基础">基础</a>中的三点中的后两点，这里<strong>使用过的iterator依旧指向原先所指的元素，但是在<code>*this</code>中, 而不是在<code>other</code>中</strong>。注意到这一点可以让我们编程中更高效，比如使用<code>splice</code>前后的iterator的从属关系变更，这个点比使用指针更加高效。</p><p>这个部分的启发来自于: <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTU2MTI3MDAvc3RsLWxpc3RzcGxpY2UtaXRlcmF0b3ItdmFsaWRpdHk=" title="https://stackoverflow.com/questions/15612700/stl-listsplice-iterator-validity">https://stackoverflow.com/questions/15612700/stl-listsplice-iterator-validity<i class="fa fa-external-link"></i></span></p><p>下面是来自三个不同地方的引用, 来解释这个<em>iterator从属关系变更</em>:</p><h2 id="cppreference-1"><a href="#cppreference-1" class="headerlink" title="cppreference 1"></a>cppreference <sup><a href="#fn1">1</a></sup></h2><p><strong>No iterators or references become invalidated, the iterators to moved elements remain valid, but now refer into <code>*this,</code> not into <code>other</code>.</strong></p><ol><li>Transfers all elements from <code>other</code> into <code>*this</code>. The elements are inserted before the element pointed to by <code>pos</code>. The container <code>other</code> becomes <strong>empty</strong> after the operation. <strong>The behavior is undefined if other refers to the same object as <code>*this</code>.</strong></li><li>Transfers the element pointed to by <code>it</code> from other into <code>*this</code>. The element is inserted before the element pointed to by <code>pos</code>.</li><li>Transfers the elements in the range $[\mathrm{first}, \mathrm{last})$ from <code>other</code> into <code>*this</code>. The elements are inserted before the element pointed to by <code>pos</code>. <strong>The behavior is undefined if <code>pos</code> is an iterator in the range $[\mathrm{first}, \mathrm{last})$.</strong></li></ol><p>以上三点对应<a href="#基础">基础</a>中的三点</p><h2 id="cplusplus-2"><a href="#cplusplus-2" class="headerlink" title="cplusplus 2"></a>cplusplus <sup><a href="#fn2">2</a></sup></h2><p>Iterator validity:<br>No changes on the iterators, pointers and references related to the container before the call.<br><strong>The iterators, pointers and references that referred to transferred elements keep referring to those same elements, but iterators now iterate into the container the elements have been transferred to.</strong></p><h2 id="C-Standard-3"><a href="#C-Standard-3" class="headerlink" title="C++ Standard 3"></a>C++ Standard <sup><a href="#fn3">3</a></sup></h2><p>23.3.5.5 list operations [list.ops]</p><p> <code>void splice(const_iterator position, list&amp; x, const_iterator i);</code><br> <code>void splice(const_iterator position, list&amp;&amp; x, const_iterator i);</code></p><p> <em>Effects:</em> Inserts an element pointed to by <code>i</code> from list <code>x</code> before <code>position</code> and removes the element from <code>x</code>. The result is unchanged if <code>position == i</code> or <code>position == ++i</code>. Pointers and references to <code>*i</code> continue to refer to this same element but as a member of <code>*this</code>. Iterators to <code>*i</code> (including <code>i</code> itself) continue to refer to the same element, but now behave as iterators into <code>*this</code>, not into <code>x</code>.</p><p><br></p><h2 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h2><p><strong>注意下面例子中<code>it</code>在<code>splice</code>前后隐式地归属于另外一个std::list</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// splicing lists</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist1, mylist2;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set some initial values:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">4</span>; ++i)</span><br><span class="line">     mylist1.push_back(i);      <span class="comment">// mylist1: 1 2 3 4</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; ++i)</span><br><span class="line">     mylist2.push_back(i*<span class="number">10</span>);   <span class="comment">// mylist2: 10 20 30</span></span><br><span class="line"></span><br><span class="line">  it = mylist1.<span class="built_in">begin</span>();</span><br><span class="line">  ++it;                         <span class="comment">// points to 2 in mylist1 (the 2th element)</span></span><br><span class="line"></span><br><span class="line">  mylist2.splice (mylist2.<span class="built_in">begin</span>(), mylist1, it);</span><br><span class="line">                                <span class="comment">// mylist1: 1 3 4</span></span><br><span class="line">                                <span class="comment">// mylist2: 2 10 20 30</span></span><br><span class="line">                                <span class="comment">// "it" is now VALID in mylist2, points to 2 (the 1st element).</span></span><br><span class="line"></span><br><span class="line">  it++;                         <span class="comment">// "it" points to 10 in mylist2 (the 2rd element).</span></span><br><span class="line">  it++;                         <span class="comment">// "it" points to 20 in mylist2 (the 3th element).</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="例子代码下载"><a href="#例子代码下载" class="headerlink" title="例子代码下载"></a>例子代码下载</h1><p><a href="https://cakebytheoceanluo.github.io/download/code/cxx/std::list::splice_1.cc">例子一下载</a></p><p><a href="https://cakebytheoceanluo.github.io/download/code/cxx/std::list::splice_2.cc">例子二下载</a></p><p>编译方法:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ std::list::splice_1.cc</span><br><span class="line">$ g++ std::list::splice_2.cc</span><br></pre></td></tr></tbody></table></figure><p><br></p><p>引用和推荐的阅读：</p><p><a name="fn1">1</a>: <span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2NvbnRhaW5lci9saXN0L3NwbGljZQ==" title="https://en.cppreference.com/w/cpp/container/list/splice">https://en.cppreference.com/w/cpp/container/list/splice<i class="fa fa-external-link"></i></span></p><p><a name="fn2">2</a>: <span class="exturl" data-url="aHR0cHM6Ly93d3cuY3BsdXNwbHVzLmNvbS9yZWZlcmVuY2UvbGlzdC9saXN0L3NwbGljZS8=" title="https://www.cplusplus.com/reference/list/list/splice/">https://www.cplusplus.com/reference/list/list/splice/<i class="fa fa-external-link"></i></span></p><p><a name="fn3">3</a>: <span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuLXN0ZC5vcmcvanRjMS9zYzIyL3dnMjEvZG9jcy9wYXBlcnMvMjAxNC9uNDI5Ni5wZGY=" title="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTA5MzE0L2FydGljbGUvZGV0YWlscy85MDU3NTAzNA==" title="https://blog.csdn.net/qq_41909314/article/details/90575034">https://blog.csdn.net/qq_41909314/article/details/90575034<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTU2MTI3MDAvc3RsLWxpc3RzcGxpY2UtaXRlcmF0b3ItdmFsaWRpdHk=" title="https://stackoverflow.com/questions/15612700/stl-listsplice-iterator-validity">https://stackoverflow.com/questions/15612700/stl-listsplice-iterator-validity<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTM4MzcxMjEvZnVuY3Rpb25pbmctb2Ytc3BsaWNlLWluLWNwcA==" title="https://stackoverflow.com/questions/13837121/functioning-of-splice-in-cpp">https://stackoverflow.com/questions/13837121/functioning-of-splice-in-cpp<i class="fa fa-external-link"></i></span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;std::list::splice&lt;/code&gt;详解&lt;/p&gt;
&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;p&gt;&lt;code&gt;splice&lt;/code&gt;方法将list的元素进行&lt;strong&gt;拼接合并&lt;/strong&gt;，原理是改变结点指针的指向，属于常数的复杂度。这个方法是&lt;code&gt;std::list&lt;/code&gt;特有的，它&lt;strong&gt;不需要复制拷贝&lt;/strong&gt;，直接对同类型的list中的节点的指针进行操作。&lt;/p&gt;
&lt;p&gt;list容器底层实现是一个带头结点的双向链表double linked list。由于list每个节点是单独的，所以list在随机插入和随机删除都是O(1)的复杂度。在list中移动数据或者两个list之间移动数据的时候，直接把节点摘下来，接入到新的位置就可以了，非常高效。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;splice&lt;/code&gt;方法有三种声明/作用/复杂度：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;entire list: &lt;code&gt;void splice ( iterator pos, list&amp;amp; other );&lt;/code&gt;　&lt;ul&gt;
&lt;li&gt;将list &lt;code&gt;other&lt;/code&gt;中的元素全都移到caller container的position处&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;复杂度: Constant&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;single element: &lt;code&gt;void splice ( iterator pos, list&amp;amp; other, iterator it );&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;仅将list &lt;code&gt;other&lt;/code&gt;中的由迭代器it指向的元素移到caller container的position处&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;复杂度: Constant&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;element range: &lt;code&gt;void splice ( iterator pos, list&amp;amp; other, iterator first, iterator last );&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;list &lt;code&gt;other&lt;/code&gt;的迭代器区间 $[\mathrm{first}, \mathrm{last})$ 中的元素移动到caller container的position处&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;复杂度: Constant if &lt;code&gt;other&lt;/code&gt; refers to the same object as &lt;code&gt;*this&lt;/code&gt;, otherwise linear in &lt;code&gt;std::distance(first, last)&lt;/code&gt;.&lt;/strong&gt; &lt;sup&gt;&lt;a href=&quot;#fn1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;caller container := 调用者容器&lt;/p&gt;
&lt;p&gt;由此可见，&lt;strong&gt;这个方法总是将list &lt;code&gt;other&lt;/code&gt;中元素移动(剪切)到caller container中。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming languages" scheme="https://cakebytheoceanluo.github.io/categories/Programming-languages/"/>
    
    
      <category term="C++" scheme="https://cakebytheoceanluo.github.io/tags/C/"/>
    
      <category term="STL" scheme="https://cakebytheoceanluo.github.io/tags/STL/"/>
    
      <category term="std::list" scheme="https://cakebytheoceanluo.github.io/tags/std-list/"/>
    
  </entry>
  
</feed>
